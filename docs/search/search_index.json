{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#idun-for-the-commodore-128-and-c64","title":"Idun for the Commodore 128 and C64","text":"<p>This is the home of the idun-cartridge for the C128/64. Here you will find the latest software, along with source code, sample applications, and other content.</p> <p>This innovative cartridge integrates a Raspberry Pi to provide a fast hardware interface, enabling features such as virtual disks, networking, and the ability to run modern applications. Users can interact with the cartridge via BASIC commands, a web-based file browser, or SSH, and the project supports developing new software in 6502 Assembly, Lua, and even C and Z80 Assembly. There's an optional Commodore Kernal patch that allow native software to access cartridge functionality at high speeds, effectively turning the cartridge into a \"hard drive\" for Commodore.</p> <p>What does it do? It's easier to show in a demo, and there are many demo videos on YouTube.</p> <p>There's also a Discord Server for the project. This is for idun-project discussion, new user advice, beta testing new features, and general retro-computing banter with a  Commodore bias.</p>"},{"location":"#hardware","title":"Hardware","text":"<p>The idun-cartridge uses a Propeller 1 micro-controller to provide a fast hardware interface between the Commodore and a Raspberry Pi (\"RPi\") that runs a customized Linux OS. The cartridge is designed to work and fit best with the Raspberry Pi Zero 2. However, any recent Raspberry Pi can be made to work.</p> <p>The first set of photos show the idun-cartridge with RPi Zero 2 fitted. As you can see, a standard-sized C64/128 cartridge case can be hacked to cover the board, but leave the RPi, ports, and button accessible.</p> <p></p> <p>A Model B RPi will also fit on an idun-cartridge, as this photo shows. For both Model Zero and Model B, the RPi is fitted on top of the idun-cartridge and upside-down. For the Model B, a case or other support is essential because of the weight.</p> <p>You can also fit a Model A RPi, but the headers must be relocated to the opposite side of both the idun-cartridge PCB and the RPi itself. In this case, the RPi will be on the bottom (under the idun-cartridge), as shown here connected to a flat C128.</p> <p></p>"},{"location":"#support-the-project","title":"Support the project","text":"<p>The best way to support the project is to buy a hardware kit from the online store. The kit comes with everything needed to assemble the idun-cartridge, except for the Raspberry Pi, which you will need to obtain yourself. Only basic soldering skills are needed, since the PCB is strictly through-hole components.</p>"},{"location":"#quick-start","title":"Quick start","text":""},{"location":"#download-sd-image","title":"Download SD Image","text":"<p>You can download the customized Arch Linux OS image and flash it to a microSD card.</p> <ol> <li>Ensure you have a suitable SD card compatible with your Raspberry Pi and at least 4GB (recommend 16 GB).</li> <li>Download Image</li> <li>Use Raspberry Pi Imager or a similar program to write image to SD card.</li> </ol> <p>Your microSD is now ready to use with your idun-cartridge. To expand the file system or setup networking, follow the additional instructions in setup-rpi.md.</p>"},{"location":"#power","title":"Power","text":"<p>It is recommended that you power the RPi externally from a USB power supply. The jumper (JP1) that allows power to come from the Commodore is not installed by default, and only suited for the RPi Zero 2. Even then, it makes it too easy to turn off the Commodore and Raspberry Pi without first shutting it down via the button. Plus, it is nice to be able to access the cartridge using the web filebrowser, emulation, or <code>ssh</code> while the Commodore is switched off.</p>"},{"location":"#cartridge-mode-reset","title":"Cartridge Mode &amp; Reset","text":"<p>The idun-cartridge has a single \"big red button\" with dual use. Press and release immediately to Reset everything, including rebooting your Commodore. Press and hold for at least 3 seconds to shutdown your cartridge, which is necessary before powering down.</p> <p>As of release v1.2.0, the idun-cartridge has two different modes, controlled by the setting of the Mode toggle switch. When the switch is \"Off\" (i.e. not switched to the \"Mode\" position), the idun-cartridge works on the C128 in its native mode. However, when switched to \"Mode\", a different software stack is selected as specified by the [mode] settings in the configuration file.</p> <p>With the default configuration file, setting the switch to the \"Mode\" position enables C64 support. This means that the cartridge can be used on a C64 and that it will boot a C128 into its C64 mode. If you are primarily wanting to play C64 games, then you can most easily do so by launching the arcade.app from BASIC using the command <code>go \"arcade\"</code>.</p>"},{"location":"#basic-commands-and-launching-apps","title":"BASIC commands and launching Apps","text":"<p>On initial boot, the cartridge starts BASIC with some utilities for accessing the Idun virtual disks. The screen lets you use the cursor keys to select which virtual drive to use and on which IEC address; the normal default is <code>C:</code>, which is the HOME directory, on IEC device 10. Once you hit \"RETURN\", you will be in Commodore BASIC.</p> <p></p> <p>From the BASIC prompt, you can use any of the several commands that are briefly described in the boot screen. Mainly, you can navigate the virtual disk by using <code>@$</code> (also <code>F3</code> on the C128) to load directories, and the <code>cd</code> command to change directories. Any disk image file can be mounted by using <code>cd</code> and prefixing the image file name with a \":\". This will switch you automatically to the <code>D:</code> device, which is where the disk is mounted. You can switch back to the <code>C:</code> device using the command <code>@c</code>, and switch to any other virtual disk this way. If you want to load and run a program, just locate it in the directory, place a <code>%</code> in column 1, and \"RETURN\". This is equivalent to typing <code>% \"prgname\"</code> on a new line.</p> <p>The other thing you can do is launch an Idun Application. This is done with the <code>go</code> command, and entering just that will quickly launch the default shell. The default shell is controlled by the configuration file, and is normally setup to load <code>dos.app</code>, which is the idun-shell and an MS-DOS work-a-like. Other applications, such as the Arcade Selector for running games can be started similarly, using <code>go \"arcade\"</code>. Any app on the cartridge can be started this way, and you can create your own using programming tools that run right on the cartridge!</p>"},{"location":"#networking-and-managing-files","title":"Networking and Managing Files","text":"<p>It's well worth connecting your cartridge to your LAN. Convenient file management can be done through the web-based idun-filebrowser at <code>idunpi:8080</code>; it even includes remote file editing and drag&amp;drop. Linux terminal access is also there using an <code>ssh</code> client from any computer. Additionally, you can stream SID tunes and setup file sharing with a Windows computer.</p>"},{"location":"#emulating-the-cartridge","title":"Emulating the Cartridge","text":"<p>You can also run idun-vice to experiment with the idun-cartridge software WITHOUT any actual cartridge; just running everything off of the Raspberry Pi.</p>"},{"location":"#configuration","title":"Configuration","text":"<p>Configuration options are available in <code>$HOME/.config/idunrc.toml</code>. There is documentation within that file, but the following hints are also helpful.</p> <ol> <li>Because of the \"special\" VDC hi-res graphic modes used by some of the software (e.g. <code>showvdc</code>), it is very important to set the correct amount of VRAM in the configuration file to either 16kB or 64kB, as appropriate. The setting is the second parameter in the <code>[vdc]</code> section.</li> <li>Some monitors are picky about how many rows of text they can display in 80 column mode, and how they look when displaying text in interlaced mode. The default is 27 rows, non-interlaced. You can modify this by changing the first parameter in the <code>[vdc]</code> section, and for interlaced text, the section <code>[vdc_interlace]</code>. Also take a look at the <code>mode</code> command for changing the number of text rows on demand (not to be confused with the mode switch described above).</li> <li>If you are using the software with only a Raspberry Pi and Vice (no idun-cartridge hardware), then pay careful attention to disable the configuration file from trying to connect with hardware that isn't there. For details, see the README for idun-vice.</li> </ol>"},{"location":"#building-commodore-code","title":"Building Commodore code","text":"<p>The idun-cartridge software in this repository is self-hosting. All of the assembly code is built with the <code>acme</code> cross-assembler and everything you need to build and modify it can be done on the cartridge itself. You can perform each of these steps from the Linux prompt:</p> <ol> <li>Clone this repository to your idun home directory: <code>git clone https://github.com/idun-project/idun-cartridge</code></li> <li><code>cd idun-cartridge &amp;&amp; ./setup.sh</code> -installs additional packages such as acme and idun-zcc.</li> <li><code>cd cbm &amp;&amp; make</code> -builds cartridge software and updates the <code>sys</code> directory (<code>z:</code> device in the idun-shell)</li> </ol> <p>See the Makefile for details.</p>"},{"location":"#patched-commodore-kernal-optional","title":"Patched Commodore Kernal (Optional)","text":"<p>The latest ROM kernal patch can be created easily with idun v1.1.9 and above using the command <code>lua makerom.lua</code> from within the Idun Shell. The patched ROM file(s) will be found in your home directory on the cartridge, and most easily copied using the web file browser or a network command like scp.</p> <p>The patches to the C128 kernal (U35) overwrite the kernal's support for RS-232 devices. This code is frequently unused by native software anyway. If you also update the C64 kernal (U32), then you lose both RS-232 and cassette tape support in C64 mode.</p> <p>With the kernal patches in place, things work pretty much the same, except that you can access cartridge functionality easily through standard Commodore ROM kernal routines, rather than loading Idun's own kernel into RAM. So, in theory, native Commodore software that is programmed to use kernal routines for file access can \"transparently\" access files via the cartridge and at \"breakneck speed\". Think of it as basically a hard drive for the Commodore without having to go through the Idun software drivers in RAM. So now those drivers can just be overwritten by some program.</p> <p>You really only need to know about two zero-page variables to control the ROM patch - $9b/$9c (155/156). So you can POKE 155, 10, for example, to setup the cartridge as IEC device #10. And, you can POKE 156, 3 to setup the cartridge to use idun's C: device, which is default configured to the Linux home directory. Using other values let's you easily switch to any Idun device mapped as any IEC device. This opens up the cartridge to native software that can use it for virtually anything without requiring RAM drivers. By the way, setting values in $9b/$9c is just what the little booter program the cartridge starts up with does - When you use the cursor keys to modify the IEC and Idun device selection, you are changing these two memory locations. </p>"},{"location":"#programming-applications","title":"Programming applications","text":"<p>The idun-cartridge works with many legacy applications. Single-file loaders in particular work very well and load instantly in either C128 or C64 mode. But the point is to enhance both the user and programmer experience with applications that integrate into the idun-cartridge. There are currently 3 well-supported ways to create software for the idun-cartridge.</p>"},{"location":"#6502-assembly","title":"6502 Assembly","text":"<p>This repository includes the acme 6502 cross-assembler, which can be used to build both the contents of this repo and your own programs on the idun-cartridge. You should first decide whether to build a Tool or an App.</p> <ol> <li>Tools load from the idun-shell using $6D00-$BFFF, have access to the kernel api and the toolbox, and return the user to the idun-shell on exit. They are typically command-line style programs, but can also take over the screen and run interactively. Many examples can be found in the cmd sub-directory</li> <li>An App is launched by the kernel at startup using $6000-$BFFF, has access to the kernel API, but not the toolbox unless <code>sys/toolbox.asm</code> is explicitly included, and return to BASIC, or not at all. They typically take over the machine and reconfigure the hardware as needed. Examples are <code>dos.app</code> (the idun-shell) and <code>arcade.app</code> (the arcade game selector).</li> </ol> <p>It is certainly possible to use other assemblers besides acme; just requiring that the header files <code>acehead.asm</code> and <code>toolhead.asm</code> be ported over to your environment.</p>"},{"location":"#lua-scripting","title":"Lua Scripting","text":"<p>The idun software running on the Raspberry Pi embeds a Lua scripting engine. This allows you to create either Tools or Apps in which much, even a majority of the functionality, is implemented in Lua.</p> <p>Begin by reading luaref.md. There is sample Lua App code in samples, and the arcade.app is Lua. These can serve as a template for creating your own Lua App.</p> <p>NOTE: There is a forthcoming tool called <code>mace</code> that will generate new Lua Apps automatically, including all the boiler-plate needed.</p>"},{"location":"#c-and-z80-assembly","title":"C and Z80 Assembly","text":"<p>You can create programs that run on the Z80! They launch seamlessly from the idun-shell, and return to it on exit. These are more akin to Apps than Tools, except for their use of the <code>zload</code> command and launching from the idun-shell. The programs can be written in a mixture of C and Z80asm code, and can be built directly on the idun-cartridge. For more information, browse to the idun-zcc repository.</p>"},{"location":"#trivia","title":"Trivia","text":"<p>Idun is the Norse goddess of youth and rejuvenation.</p>"},{"location":"idun-base/","title":"Included Samples","text":""},{"location":"idun-base/#idun-base","title":"idun-base","text":"<p>This repository contains some content intended to help users become familiar with some of the capabilities of the idun-cartridge. There are 7 sub-directories.</p>"},{"location":"idun-base/#c64-pd-games","title":"C64-PD-Games/","text":"<p>Contains several hundred public domain C64 games, most of which can be launched from the idun-cartridge. This sub-directory is setup as the <code>G:</code> drive in the default SD card image. A <code>gamelist.csv</code> file is included, and allows these games to be used in the cart's Arcade mode. Demo videos for Arcade mode exist on the project's YouTube page.</p>"},{"location":"idun-base/#apps","title":"apps/","text":"<p>Contains some Lua sample applications. Run them from the idun-shell by simply typing the name, such as <code>cube.app</code>. Most can be exited with the STOP key to return to the shell. Some have a popup menu, which is activated using <code>C= + \u27f5</code>.</p>"},{"location":"idun-base/#demos","title":"demos/","text":"<p>Contains two single-file .prg demos for C64 mode and one .d64 image of the C128 VDC graphics demo \"Risen from Oblivion\".</p> <ul> <li>For the C64 demos, first <code>cd</code> to this directory in idun-shell, then enter C64 mode with the <code>go64</code> command. From the C64 basic prompt, use <code>RUN\"&lt;filename&gt;.prg\"</code> to load and run the demos.</li> <li>For the C128 VDC demo, first use the <code>mount</code> command to attach the .d64 image to device D. Then, <code>reboot</code> to return to C128 BASIC, and map device D: to unit 10 (the default). Use <code>run\"risen*\",u10</code> to start the demo.</li> </ul>"},{"location":"idun-base/#games","title":"games/","text":"<p>Contains several C128 games, a Galaga port for C64 mode, \"shareware\" version of PETSCII Robots 128, and two interactive fiction titles for playing in <code>frotz</code>.</p> <ul> <li>Start <code>galaga</code> or <code>galaga-usb</code> from C64 mode similar to the C64 demos.</li> <li>Mount <code>Robots-128.d71</code> on <code>D:</code> and select <code>D:</code> as the idun device. Press <code>F5</code> in BASIC to launch the game booter. Use your already configured USB gamepad to control the game.</li> <li>Mount the disk images for the C128 games and use either <code>load</code> from idun-shell or <code>run</code> from the basic prompt to start them.</li> <li><code>frotz</code> is a Linux program that is not installed by default. You can add it from the Linux shell with <code>sudo pacman -S frotz-ncurses</code>. Then, also from the Linux shell, start the game with a command like <code>frotz &lt;z-file-name&gt;</code>.</li> </ul>"},{"location":"idun-base/#pics","title":"pics/","text":"<p>Contains many pics viewable using the VDC/80-column or the VIC-II/40-column display. + Use the <code>showvdc</code> command in the idun-shell to display images in the mono/ and vdc-color/ directories. Note: most images are hi-res and will require 64kB VRAM. + Use the <code>showzx</code> command in the idun-shell to display images in the spectrum/ directory. These are low-res and will work with 16kB VRAM. + Use <code>koala.app</code> in the idun shell to display VIC-II Koala format images. Sample images are in the koa/ sub-directory. + <code>ansilove.ans</code> is a color ANSI graphic useful for testing. Use <code>mode ans</code> to load ANSI character set, then <code>linux \"cat ansilove.ans\"</code> to display the file in the tty.</p>"},{"location":"idun-base/#sids","title":"sids/","text":"<p>Contains 50+ SID music files that can be played from the idun-shell using the <code>sidplay</code> command.</p>"},{"location":"idun-base/#z80","title":"z80/","text":"<p>Contains sample C code programs for the Z80 mode. These are compiled from the Linux prompt using <code>zcc</code>, then can be run from the idun Dos shell with the <code>zload</code> command. To build, just run <code>make</code> from the src/ sub-directory. For more details, take a look at the idun-zcc repository and the Z88dk page.</p>"},{"location":"idun-cpem/","title":"CP/M Support","text":"<p>This repository contains CPem; a modified version of the excellent \"RunCPM\" emulator by Marcelo Dantas. CPem has been improved to work with the idun-cartridge and to support the real z80 CPU when running programs on a Commodore 128.</p>"},{"location":"idun-cpem/#getting-started","title":"Getting Started","text":"<p>You can install this software on your idun-cartridge using the following pacman command from the Linux prompt: <code>sudo pacman -Sy idun-cpem</code>. You also need the \"cpm.app\" that is part of the cartridge project. This is included from v1.2.1 of idun-cartridge onward.</p> <p>You can launch directly into CPem from the Commodore BASIC prompt using the command <code>go \"cpm\"</code>. You can also start CPem from the idun-shell by simply typing <code>cpm</code>.</p> <p>Once started, you will be in a CP/M v2.2 compatible OS that can run \"vanilla\" CP/M text programs. The environment is emulated on the Raspberry Pi's ARM processor, so CP/M programs run super fast. You can use all the standard CP/M commands, plus some additional built-in commands. To see the built-in commands, enter <code>?</code>. To see what CP/M software is available, you can enter <code>drives</code> to get a list of disk drives, then enter <code>vol a:</code>, <code>vol b:</code>, etc. to see what is on each drive. You can switch to drive B, for example, by entering <code>b:</code> and to user area 1 by entering either <code>user 1</code> or <code>b1:</code>.</p> <p>The terminal is VT-100 compatible. Therefore, CP/M programs that are setup to use VT-100 will work best. You can use CPem in 40-column mode and on the Commodore 64. However, be aware that many CP/M programs expect an 80-column text display. If you have weird looking text output from a CP/M program, you should investigate what kind of terminal it is setup to use. CP/M software compatibility problems that can be improved by modifying the CP/M software, its setup, or the idun-cartridge VT-100 emulation abilities can be reported here using GitHub's \"Issues\" reporting.</p>"},{"location":"idun-cpem/#running-programs-on-real-z80","title":"Running programs on real Z80","text":"<p>If you are using the idun-cartridge on a Commodore 128, then you have the best of both worlds- fast, emulated performance along with the ability to launch programs on the C128's Z80 CPU. CPem's command processor will assume that any command with a \".Z80\" extension is a native program intended to run on the C128. Such programs are identical to the programs also supported by the <code>zload</code> command used to launch them from idun-shell. These programs are most easily created using the ZCC cross-compiler from idun-zcc. Some sample programs are available on drive <code>c1:</code>.</p>"},{"location":"idun-cpem/#development-tools","title":"Development Tools","text":"<p>CP/M might be best remembered for the large selection of software development tools it offered. Default drive <code>A0:</code> includes Z80 assemblers and <code>mbasic</code>. Other drives include C, Pascal, and BASIC compilers. Plus there is BBCBASIC and a Forth language compiler. All of these CP/M dev tools run very fast and can thus provide an enjoyable way to learn as much as you ever wanted to know about CP/M programming.</p> <p>The ZCC cross-compiler that is also installed on the idun-cartridge can build both native c128 and CP/M programs. ZCC is based on the excellent Z88DK project. It has an extensive library and provides a more \"modern\" C programming experience. </p>"},{"location":"idun-cpem/#access-cpem-remotely","title":"Access CPem remotely","text":"<p>When you installed the idun-cpem package, it will have created a new <code>cpm</code> user account. The reason this account exists is to turn the idun-cartridge into a remote CP/M terminal that you can access from your PC using ssh. Just login using <code>ssh cpm@idunpi</code> (default password <code>idun</code>). This user account drops you directly into CPem. If you only have a 40-column display for your Commodore, then you might find the PC terminal to be a good alternative. It's also very convenient since you can leave the cartridge powered up and use it this way when your Commodore is turned off.</p>"},{"location":"idun-cpem/#future-possibilities","title":"Future possibilities...","text":"<p>BIOS extensions and/or driver libraries to allow CP/M programs running on the emulated (accelerated) Z80 to directly access the Commodore's VIC-II or VDC to display text and graphics.</p>"},{"location":"idun-filebrowser/","title":"Web File Access","text":"<p>filebrowser provides a file managing interface within a specified directory and it can be used to upload, delete, preview, rename and edit your files. It allows the creation of multiple users and each user can have its own directory. It can be used as a standalone app.</p>"},{"location":"idun-filebrowser/#features","title":"Features","text":"<p>Please refer to our docs at https://filebrowser.org/features</p>"},{"location":"idun-filebrowser/#install","title":"Install","text":"<p>For installation instructions please refer to our docs at https://filebrowser.org/installation.</p>"},{"location":"idun-filebrowser/#configuration","title":"Configuration","text":"<p>Authentication Method - You can change the way the user authenticates with the filebrowser server</p> <p>Command Runner - The command runner is a feature that enables you to execute any shell command you want before or after a certain event.</p> <p>Custom Branding - You can customize your File Browser installation by change its name to any other you want, by adding a global custom style sheet and by using your own logotype if you want.</p>"},{"location":"idun-filebrowser/#contributing","title":"Contributing","text":"<p>If you're interested in contributing to this project, our docs are best places to start https://filebrowser.org/contributing.</p>"},{"location":"idun-project.github.io/","title":"idun-project.github.io","text":""},{"location":"idun-project.github.io/#documentation-and-package-repository","title":"Documentation and Package Repository","text":"<p>Arch Linux packages for the idun-cartridge are hosted on this site in the <code>/packages</code> directory. In order to perform updates using the <code>pacman</code> command, the repository must be properly configured. If you simply download the default SD image for the idun-cartridge, then this repository will be used, beginning with v1.1.7. In order to configure the repository manually on an existing SD card, perform the following steps.</p> <ol> <li>Update the file <code>/etc/pacman.conf</code> adding the following at the end of the file.</li> </ol> <pre><code>[idun-repo]\nSigLevel = Optional TrustAll\nServer = https://idun-project.github.io/packages\n</code></pre> <ol> <li>Download the public key used for package signing <code>wget https://idun-project.github.io/repo_pub.gpg</code></li> <li>Install the key <code>sudo pacman-key -a repo_pub.gpg</code></li> <li>Update package databases <code>sudo pacman -Sy</code></li> </ol> <p>After this, the idun-repo should be available and you can install/update idun packages with a command such as <code>pacman -S idun idun-base idunsid idun-filebrowser</code>. Also, you can shorten this to <code>pacman -Suy</code> to update ALL packages you have installed. BEWARE: This has the potential to introduce changes that could break compatibility with the idun software. In particular, new versions of the Linux kernel which are \"bleeding-edge\" might have compatibility issues. If you find this is happening, please post your findings as an \"Issue\".</p>"},{"location":"idun-vice/","title":"Emulator","text":""},{"location":"idun-vice/#vice-emulator-for-idun-cartridge","title":"Vice Emulator for Idun Cartridge","text":"<p>Developing for the idun cart can be done using Vice. This patched version of Vice connects to the Raspberry Pi on your Idun cartridge and lets you run an emulated environment either directly on the Raspberry Pi, or from a remote PC. Most of the features of the idun cart are available through the emulator, including developing apps that use Lua. What does not work is the <code>go64</code> and <code>load</code> commands from the idun shell.</p> <p>This emulator can also work for development even if you lack the actual idun cartidge hardware. You can download the image for idun, burn it to an SD card, and use it to boot most versions of Raspberry Pi. You need a RPi with ARMv7, at least 512MB of RAM, and a 4GB SD card.</p>"},{"location":"idun-vice/#installation","title":"Installation","text":"<p>To use the emulator on the Raspberry Pi connected with your idun cart, install the latest release from the idun package repository. If you are new to <code>pacman</code>, consider perusing the Arch Linux pacman primer.</p> <pre><code>sudo pacman -Sy idun-vice\n</code></pre> <p>Connect a keyboard to your RPi, and start the emulator using the included launch script <code>idun-vice/emu.sh</code>. The emulator runs fullscreen using SDL2. Press F12 to access the Vice menu.</p> <p>Note: <code>idun-vice/emu64.sh</code> is sort of ancillary. It exists mainly because the <code>go64</code> shell command doesn't work in the emulator. Instead, you can exit the x128 emulator (<code>emu.sh</code>), and start the x64sc emulator (<code>emu64.sh</code>), without upsetting the state of the cartridge.</p>"},{"location":"idun-vice/#building","title":"Building","text":"<p>This GitHub repo is fully buildable on a RPi.</p> <pre><code>git clone https://github.com/idun-project/idun-vice.git\ncd idun-vice\n./buildpkg.sh\n</code></pre> <p>If you want to build modified Vice binaries for other platforms, then start in directory <code>idun-vice/vice</code> and build things the normal way using <code>configure</code> and <code>make</code>, or follow the details for your platform in the Vice documentation.</p>"},{"location":"idun-vice/#using-without-idun-cartridge","title":"Using without idun-cartridge","text":"<ul> <li>You will need to edit <code>~/.config/idunrc.toml</code> and comment out the setting for <code>io.serial</code> such as shown below. This will stop the RPi continually trying to re-connect with the cartridge, otherwise it's unusable!</li> </ul> <pre><code>[io]\n#serial     = \"/dev/ttyAMA0\"\n</code></pre> <ul> <li>You will also need to make an addition to <code>/etc/systemd/system/idun.service</code>. In the section under <code>[Service]</code>, add an additional line<ul> <li><code>Environment=IDUN_MODE_SWITCH=False</code></li> <li>This variable is used to toggle whether the Mode switch is seen as enabled when you don't have an actual idun-cart connected to the RPi.</li> </ul> </li> <li>To connect to the RPi from a PC running the emulator, make sure <code>io.devsock</code> is set as shown below. Otherwise, only local connection is allowed!</li> </ul> <pre><code>[io]\ndevsock = \"0.0.0.0:25232\"   # allow remote emulator connection\n</code></pre>"},{"location":"idun-zcc/","title":"Z80","text":""},{"location":"idun-zcc/#idun-zcc","title":"idun-zcc","text":"<p>This repository contains packaging scripts and C library patches to easily install the Z80 compiler, assembler, and C128 libs from the Z88DK project on the idun-cartridge.</p> <p>Using the installed tools, you can easily build C and Z80 asm programs for the Z80 directly on the cartridge, then launch those Z80 programs on your C128 from the idun Dos shell with the <code>zload</code> command.</p> <p></p>"},{"location":"idun-zcc/#how-to-use","title":"How to Use","text":"<p>The main tool for using the Z80 compiler/assembler is <code>zcc</code>. This runs on the Raspberry Pi in the idun-cart and cross-compiles Z80 code for the C128. In most cases, you just need a command line like this to build your program:</p> <pre><code>zcc +c128 &lt;.c files&gt; &lt;.asm files&gt; -o &lt;progname&gt;\n</code></pre> <p>Any number or mix of both C and asm files is supported, and the .c files also support inline assembly code too. The entry point to your program is the <code>main()</code> function in any of the .c files. Once built, you can directly launch the Z80 program from the idun shell using <code>zload &lt;progname&gt;</code>.</p>"},{"location":"idun-zcc/#how-to-install","title":"How to Install","text":"<p>Grab the latest SD card image for the idun-cart, which includes this package by default. Or, download the release from this repository using <code>wget</code> and install it on your cart using <code>sudo pacman -U idun-zcc-*</code>. You'll also need to update the main idun package (adds <code>zload</code>) and the content from the <code>idun-base</code> repository to get the sample code files.</p>"},{"location":"idun-zcc/#whats-included","title":"What's Included","text":"<p>The C and asm source code for targeting the C128 is included in this repository with the patches needed to make binaries that are compatible with the idun-cart. Additionally, this provides a place to add/contribute new library code that works with the idun-cart.</p> <p>You also get all the supporting tools and documentation from the Z88DK project installed from the package. Technically, you can use it to build for other Z80 systems (about 100 systems supported). To learn more, definitely check out both the Z88DK home page and their git repository.</p>"},{"location":"idun-zcc/#important-technical-notes","title":"Important Technical Notes","text":"<p>This works really well on the idun-cart, allowing near seamless and fast launching/switching between 6502 and Z80 programs. It is (imo) a far better user experience than CP/M ever was, at least on the C128. This is mainly accomplished with adherence to memory partitioning.</p> <ul> <li>The 6502 and idun software owns RAM bank 0, and uses RAM bank 1 for dynamically allocated high-speed cache.</li> <li>The Z80 programs run out of RAM bank 1, and can use 52K for code and data starting from $3000.</li> <li>The <code>zload</code> command does all the setup necessary to load and launch the Z80 program plus cleanly return to the shell when the program exits.</li> <li>An additional 8K of RAM 1 ($1000-$2FFF) is set aside for VIC-II use by the Z80 program. This is enough to support text mode with custom character sets, bitmap mode, or hardware sprites.</li> <li>The Z80 ROM BIOS is \"just there\" from $0000-$0fff. This might be useful for accessing peripherals such as the 1571 floppy drive, etc.</li> <li>Of course, the Z80 program has full control over the VDC, VIC-II, SID, MMU, and CIA chips while the program runs. It is likely possible to put these things in a state that causes the shell to crash on exit, though.</li> </ul>"},{"location":"idun-zcc/#what-about-cpm","title":"What about CP/M?","text":"<p>You can (in theory) use this package as installed to also build Z80 programs for use with C128 CP/M. Just modify the compile command to use <code>zcc +cpm ...</code> This has not been tested.</p>"},{"location":"idun-zcc/#todos","title":"TODOs","text":"<p>Helpful enhancements include, but aren't limited to:</p> <ul> <li>[ ] Standard C library functions for file access (e.g. open, read, write, close). These would give Z80 programs easy access to virtual drives, files, and devices on the idun-cart.</li> <li>[ ] Better VIC-II support, such as hardware sprite usage from C.</li> <li>[ ] Porting over some reasonable text mode UI support.</li> <li>[ ] Porting over or creating more demo and application sample code.</li> </ul>"},{"location":"idunSID/","title":"idunSID","text":"<p><code>idunsid</code> is a fork of sid-device, a cross-platform Network SID Device. It runs as a service on the idun-cartridge to allow SID tunes to be played from a Windows client over the network, using either emulated sound or the real SID chip in your Commodore.</p> <p>Note: requires idun-cartridge software v1.0.2 or later.</p> <p>Hopefully, a demo video is worth a thousand words!</p> <p><code>idunsid</code> can be used by SID-players like: ACID 64 Player Pro,  ACID 64 console player and JSidplay2.</p> <p>Embedded within <code>idunsid</code> is the emulation engine reSID v1.0, which is the very same SID emulator found in the Commodore emulator - Vice.</p> <p>The original author started with the goal to turn a Raspberry Pi into a SID device. <code>idunsid</code> does that, but also connects to the real SID hardware via the idun-cartridge. You can use the player \"client\" applications listed above with your Commodore switched off, and sound will play through the headphone jack of the RPi using reSID's awesome emulation. But, with the Commodore switched on, and \"Real SID\" selected for output in the client, the actual SID chip is used. Furthermore, your Commodore is still accessible and can run any tools you like from the idun-shell.</p> <p>Finally, multi-tasking with background SID tunes on an 8-bit Commodore!</p> <p>Tip: When using reSID emulation. select \"Fast\" as the \"Sampling method\" for greatly improved emulation performance on the RPi.</p>"},{"location":"idunSID/#installation","title":"Installation","text":"<p><code>idunsid</code> is included on the latest version of the RPi image file. If it is not already installed on your SD card, then download the release package from this repository, and install it using pacman.</p> <pre><code>sudo pacman -U idunsid-1.0-1-armv7h.pkg.tar.zst\n</code></pre>"},{"location":"idunSID/#development","title":"Development","text":"<p>To build the source code you need to have the following tools installed:  Rust, Clang. </p>"},{"location":"idunSID/#documentation","title":"Documentation","text":"<p>For documentation about the network SID interface, see the Network SID Device V4 specification, converted from the JSidplay2 project.</p>"},{"location":"idunSID/#thanks","title":"Thanks","text":"<p>Thanks to Dag Lem and all the team members and ex-team members of Vice who helped with the SID chip emulation.</p> <p>Thanks to Ken H\u00e4ndel and Antti S. Lankila for creating the network SID interface that is used in JSidplay2 and JSidDevice.</p> <p>Thanks to Wilfred Bos for sid-device and player applications.</p>"},{"location":"idunSID/#copyright","title":"Copyright","text":"<p>SID Device v1.0 \u2013 Copyright \u00a9 2021 - 2022 by Wilfred Bos</p> <p>Network SID Interface \u2013 Copyright \u00a9 2007 - 2022 by Wilfred Bos, Ken H\u00e4ndel and Antti S. Lankila</p> <p>reSID v1.0 \u2013 Copyright \u00a9 1998 - 2022 by Dag Lem</p> <p>idunsid v1.0 \u2013 Copyright \u00a9 2023 by Brian Holdsworth</p>"},{"location":"idunSID/#licensing","title":"Licensing","text":"<p>The source code is licensed under the GPL v3 license.</p>"},{"location":"doc/apiref/","title":"Idun/ACE-128 PROGRAMMER'S REFERENCE GUIDE (v1.0)","text":"<p>Originally by Craig Bruce 09-Feb-1997. Revised for Idun beginning in 2023.</p> <ul> <li>Introduction</li> <li>Reference</li> <li>SYSTEM VARIABLES AND CONSTANTS<ul> <li>1. ZERO-PAGE VARIABLES</li> <li>2. SYSTEM VARIABLES</li> <li>3. SYSTEM CONSTANTS</li> </ul> </li> <li>SYSTEM CALLS<ul> <li>1. FILE CALLS</li> <li>2. DIRECTORY CALLS</li> <li>3. SCREEN-CONTROL CALLS</li> <li>4. CONSOLE CALLS</li> <li>5. GRAPHICS CALLS</li> <li>6. PROCESS-CONTROL CALLS</li> <li>7. MEMORY CALLS</li> <li>8. TIME CALLS</li> <li>9. TTY ACCESS CALLS</li> <li>10. NEW MEMORY API FOR ERAM</li> <li>11. MISCELLANEOUS CALLS</li> <li>12. IOCTL CALLS</li> </ul> </li> <li>USER-PROGRAM ORGANIZATION</li> </ul>"},{"location":"doc/apiref/#introduction","title":"Introduction","text":"<p>The core of the Idun software is comprised of a kernel, device drivers, command-line shell, and application API originally written by Craig Bruce in 1992-1997, and modified for Idun 30 years later. While the original shell was inspired by Unix, the one included with Idun is intended to be reminiscent of MS-DOS. The kernel and device drivers have been modified to work with the idun-cartridge, and many additions have been made to the API. This document covers the API. This API is used by all the tools that are included with and run within the idun-shell (see: dos.app.s). Perhaps, the best way to learn the API is to look at the assembly language source code for the tools (see: cbm/cmd/), and consult the reference below for better understanding.</p>"},{"location":"doc/apiref/#reference","title":"Reference","text":""},{"location":"doc/apiref/#system-variables-and-constants","title":"SYSTEM VARIABLES AND CONSTANTS","text":"<p>This section describes the interface between user programs and the Idun kernel.  I am very careful throughout this interface specification about revealing any internal details that you do not strictly need to know.  The interface with Idun is not specified in terms of absolute addresses; to aid in portability and extensibility, all interfaces are specified in terms of symbolic assembler labels.  All of the Idun code is currently written for the ACME assembler. Also, because these interface absolute addresses are subject to change from version to version of the kernel, executables compiled for use with an old version of Idun may not work with a new version.</p>"},{"location":"doc/apiref/#1-zero-page-variables","title":"1. ZERO-PAGE VARIABLES","text":"<p>There are four zero-page variables used for passing arguments in most system calls.  They are as follows:</p> <pre><code>SYMBOL   BYTES   DESCRIPTION\n-------  -----   -----------\nzp           2   zeropage pointer\nzw           2   zeropage word\nmp           4   memory pointer\nsyswork     16   system work area / arguments\n</code></pre> <p>The first two, \"zp\" and \"zw\" are used in many calls.  They store simple 16-bit values; \"zp\" usually stores pointers to strings in application memory.  The \"mp\" variable is 32-bits in length and is used exclusively for passing far memory pointers for use with the far memory routines.  All three of these variables will remain unchanged inside of system call unless they will contain a return value.  \"syswork\" is a 16-byte array used mainly when there are too many arguments for other variables to hold, and all non-input and non-output bytes of \"syswork\" are subject to change by the kernel.  All input arguments placed in the \"syswork\" locations will be preserved unless otherwise indicated.</p>"},{"location":"doc/apiref/#2-system-variables","title":"2. SYSTEM VARIABLES","text":"<p>There are several non-zeropage variables for storing system status and return values:</p> <pre><code>SYMBOL          BYTES   DESCRIPTION\n----------      -----   -----------\nerrno               1   error number code returned by failed system calls\naceArgc             2   argument count for current process\naceArgv             2   argument vector address for current process\naceMemTop           2   highest address, plus one, that user prog can use\naceDirentBuffer &lt;next&gt;  storage for directory entries read from disk\naceDirentLength     -   really a constant: length in bytes of \"aceDirentBuffer\"\naceDirentBytes      4   bytes in file (usually inexact)\naceDirentDate       8   date of file in \"YY:YY:MM:DD:HH:MM:SS:TW\" format\naceDirentType       4   type of file in null-terminated string\naceDirentFlags      1   flags of file, \"drwx*-et\" format\naceDirentUsage      1   more flags of file, \"ulshm---\" format\naceDirentNameLen    1   length of name of file\naceDirentName      17   null-terminated name of file\naceExitData       256   storage for exit status from the last called prg\naceMouseLimitX      2\naceMouseLimitY      2\naceMouseScaleX      1\naceMouseScaleY      2\n</code></pre> <p>ERRNO: \"errno\" is used to return error codes from system calls.  When a system call ends in error, it sets the carry flag to \"1\", puts the error code in \"errno\", and returns to the user program, after undoing any system work completed at the time the error is encountered and aborting the operation.  An error code number is stored in binary in the single-byte \"errno\" location. The symbolic names for the possible error codes are given in the next section. If no error occurs in a system call, the carry flag will be cleared on return from the call.  Note that not all system calls can run into errors, so not all set the carry flag accordingly.</p> <p>ARGC: \"aceArgc\" is a two-byte unsigned number.  It gives the number of arguments passed to the application by the program (usually the command shell) that called the application.  The first argument is always the name of the application program, so the count will always be at least one.  Other arguments are optional.</p> <p>ARGV: \"aceArgv\" is a two-byte RAM0 pointer.  Pay attention.  This pointer points to the first entry of an array of two-byte pointers which point to the null-terminated strings that are the arguments passed to the application program by the caller.  (A null-terminated string is one that ends with a zero byte).  To find the address of the N-th argument to an application, multiply N by two, add the \"aceArgv\" contents to that, and fetch the pointer from that address.  In this scheme, the ever-present application name is the 0-th argument.  The argv[argc] element of the argument vector will always contain a value of $0000, a null pointer.</p> <p>MEM-TOP: \"aceMemTop\" is a two-byte RAM0 pointer.  This points to one byte past the highest byte that the application program is allowed to use.  All application programs are loaded into memory at address \"aceToolAddress\" (next section), and all memory between the end of the progam code and \"aceMemTop\" can be used for temporary variables, file buffers, etc.  The main problem with this approach is that there are no guarantees about how much memory your application will get to play with.  Many applications, such as simple file utilities, can simply use all available memory for a file buffer, but other programs, such as a file compressor, may have much greater demand for \"near\" memory.</p> <p>DIRENT-BUFFER: \"aceDirentBuffer\" is a buffer used for storing directory information read with the \"dirread\" system call, and is \"aceDirentLength\" bytes long.  Only a single directory entry is (logically) read from disk at a time.  The individual fields of a read directory entry are accessed by the fields described next.  This field is also used for returning disk name information and the number of bytes free on a disk drive (see the \"dirread\" system call).</p> <p>DIRENT-BYTES: \"aceDirentBytes\" is a four-byte (32-bit) unsigned field.  As always, the bytes are addressed from least significant to most significant. This field gives the number of bytes in the file.  Note that this value may not be exact, since Commodore decided to store sizes in disk blocks rather than bytes.  For devices that report only block counts (i.e., every disk device currently supported), the number of bytes returned is the number of blocks multiplied by 254.  This field, as well and the other dirent fields are absolute addresses, not offsets from aceDirentBuffer.</p> <p>DIRENT-DATE: \"aceDirentDate\" is an eight-byte array of binary coded decimal values, stored from most significant digits to least significant.  The first byte contains the BCD century, the second the year, and so on, and the last byte contains the number of tenths of seconds in its most significant nybble and a code for the day-of-week in its least significant nybble.  Sunday has code 0, Monday 1, etc., Saturday 6, and a code of 7 means \"unknown\".  This is the standard format for all dates used in ACE.  This format is abstracted as \"YY:YY:MM:DD:HH:MM:SS:TW\".  For disk devices that don't support dates, this field will be set to all zeroes.</p> <p>DIRENT-TYPE: \"aceDirentType\" is a three-character (four-byte) null- terminated string.  It indicates what type the file is, in lowercase PETSCII.  Standard types such as \"SEQ\" and \"PRG\" will be returned, as well and other possibilities for custom device drivers.</p> <p>DIRENT-FLAGS: \"aceDirentFlags\" is a one-byte field that is interpreted as consisting of eight independent one-bit fields.  The abstract view of the fields is \"drwx-et\".  \"d\" means that the item is a subdirectory (otherwise it is a regular file), \"r\" means the item is readable, \"w\" means the item is writable, and \"x\" means the item is executable.  The \"x\" option is really not supported currently.  \"\" means the item is improperly closed (a \"splat\" file in Commodore-DOS terminology).  The \"-\" field is currently undefined. \"e\" means that the value given in the \"aceDirentBytes\" field is actually exact, and \"t\" means the file should be interpreted as being a \"text\" file (otherwise, its type is either binary or unknown).  The bit fields are all booleans; a value of \"1\" means true, \"0\", false.  The \"d\" bit occupies the 128-bit position, etc.</p> <p>DIRENT-USAGE: \"aceDirentFlags\" is a one-byte field very much like \"aceDirentFlags\".  The abstract view of the fields is \"ulshm---\".  \"u\" indicates whether the directory entry is used (current) or not (deleted). The directory system calls will not read a directory entry that is deleted, so you will never see this bit not set; it is used internally.  \"l\" indicates whether the directory entry is for an actual file (==0, normal) or a \"link\" (==1) to another file.  The \"s\" and \"h\" bits indicate which type a link is:  \"soft\" or \"hard\", respectively.  These both work similarly to Unix hard and soft links.  The \"m\" flag indicates whether a file has been modified since the last time that a backup program cleared the \"m\" bit for the file, allowing incremental backups.</p> <p>DIRENT-NAME-LEN: \"aceDirentNameLen\" is a one-byte number.  It gives the number of characters in the filename.  It is present for convenience.</p> <p>DIRENT-NAME: \"aceDirentName\" is a 16-character (17-byte) null-terminated character string field.  It gives the name of the file or directory or disk.  Filenames used with Idun are limited to 16 characters.</p> <p>EXIT-DATA: \"aceExitData\" is a 256-byte array.  It is the 256-byte buffer allocated for user programs to give detailed return information upon exiting back to their parent program.  See the \"exit\" system call.  User programs are allowed to read and write this storage.  An example use of this feature would be a compiler program returning the line number and character position, and description of a compilation error to a text editor, so the editor can position the cursor and display the error message for user convenience.  The implementation of this feature may need to change in future versions of ACE.</p>"},{"location":"doc/apiref/#3-system-constants","title":"3. SYSTEM CONSTANTS","text":"<p>There are several symbolic constants that are used with the Idun system interface:</p> <pre><code>SYMBOL                   DESCRIPTION\n-------------------      -------------------------\naceToolAddress           the start address of tools that run from the shell\naceID1                   the id characters used to identify Idun applications\naceID2                   ...\naceID3                   ...\naceMemNull               the far memory type code used to indicate null ptrs\naceMemREU                far mem type code for Ram Expansion Unit memory\naceMemTagged             far mem type code for tagged RAM memory\naceMemInternal           far mem type code for internal memory\naceErrStopped            error code for syscall aborted by STOP key\naceErrTooManyFiles       err: too many files already opened to open another\naceErrFileOpen           err: don't know what this means\naceErrFileNotOpen        err: the given file descriptor is not actually open\naceErrFileNotFound       err: named file to open for reading does not exist\naceErrDeviceNotPresent   err: the specified physical device is not online\naceErrFileNotInput       err: file cannot be opened for reading\naceErrFileNotOutput      err: file cannot be opened for writing\naceErrMissingFilename    err: pathname component is the null string\naceErrIllegalDevice      err: the specified device cannot do what you want\naceErrWriteProtect       err: trying to write to a disk that is write-protected\naceErrFileExists         err: trying to open for writing file that exists\naceErrFileTypeMismatch   err: you specified the file type incorrectly\naceErrNoChannel          err: too many open files on disk drive to open another\naceErrInsufficientMemory err: Idun could not allocate the memory you requested\naceErrOpenDirectory      err: you are trying to open a dir as if it were a file\naceErrDiskOnlyOperation  err: trying to perform disk-only op on char device\naceErrNullPointer        err: trying to dereference a null far pointer\naceErrInvalidFreeParms   err: bad call to \"aceMemFree\": misaligned/wrong size\naceErrFreeNotOwned       err: trying to free far memory you don't own\naceErrInvalidWindowParms err: invalid window dimensions were given\naceErrInvalidConParms    err: invalid console parameters were given\naceErrInvalidFileMode    err: opening a file for other-than \"r\",\"w\", or \"a\"\naceErrNotImplemented     err: system call or option is not (yet) implemented\naceErrBloadTruncated     err: a bload operation stopped before exceeding limit\naceErrPermissionDenied   err: attempt to read or write a file without perms\naceErrNoGraphicsSpace    err: graphics area is not available for operation\naceErrBadProgFormat      err: specified program file has wrong format\nchrBEL                   character code: bell\nchrTAB                   character code: tab\nchrBOL                   character code: beginning of line (return)\nchrCR                    character code: carriage return (newline)\nchrVT                    character code: vertical tab (down, linefeed)\nchrBS                    character code: backspace (del)\nchrCLS                   character code: clear screen (form feed)\nchrBUL                   character code: bullet\nchrVL                    character code: v_line\nchrHL                    character code: h_line\nchrCRS                   character code: cross\nchrTL                    character code: tl_corner\nchrTR                    character code: tr_corner\nchrBL                    character code: bl_corner\nchrBR                    character code: br_corner\nchrLT                    character code: l_tee\nchrRT                    character code: r_tee\nchrTT                    character code: t_tee\nchrBT                    character code: b_tee\nchrHRT                   character code: heart\nchrDIA                   character code: diamond\nchrCLU                   character code: club\nchrSPA                   character code: spade\nchrSCI                   character code: s_circle\nchrOCI                   character code: circle\nchrLBS                   character code: pound\nchrCHK                   character code: CLS/check\nchrPI                    character code: pi\nchrPM                    character code: +/-\nchrDIV                   character code: divide\nchrDEG                   character code: degree\nchrCHE1                  character code: c_checker\nchrCHE2                  character code: f_checker\nchrSOL                   character code: solid_sq\nchrCRE                   character code: cr_char\nchrUP                    character code: up_arrow\nchrDWN                   character code: down_arro\nchrLA                    character code: left_arro\nchrRA                    character code: right_arr\nstdin                    file descriptor reserved for stdin input stream\nstdout                   file descriptor reserved for stdout output stream\nstderr                   file descriptor reserved for stderr output stream\n</code></pre> <p>\"aceToolAddress\", as discussed before, is the address that application programs are loaded into memory at.  They must, of course, be assembled to execute starting at this address.</p> <p>The \"aceMem\" group of constants are for use with the \"aceMemAlloc\" system call, except for \"aceMemNull\", which may be used by application programs for indicating null far pointers.  The \"aceMemAlloc\" call allows you to specify what types of memory you are willing to accept.  This is important because the difference types of memory have different performance characteristics. Idun will try to give you the fastest memory that is available.  Ram Expansion Unit memory has startup and byte-transfer times of about 60 us (microseconds) and 1 us, respectively.  This is the fastest type of far memory.  Internal memory has a startup time of 24 us and a byte-transfer time of between 7 and 14 us (depending on whether accessing RAM0 or RAM1+).</p> <p>The \"aceErr\" group gives the error codes returned by system calls.  The error codes are returned in the \"errno\" variable.  Not all possible error codes from Commodore disk drives are covered, but the important ones are. The \"chr\" group gives the character codes that have special control functions when printed using the \"write\" system call (below).</p> <p>Finally, the \"std\" files group give the symbolic file descriptor identifiers of the default input, output, and error output file streams.</p>"},{"location":"doc/apiref/#system-calls","title":"SYSTEM CALLS","text":"<p>All system calls are called by setting up arguments in specified processor registers and memory locations, executing a JSR to the system call address, and pulling the return values out of processor registers and memory locations.</p>"},{"location":"doc/apiref/#1-file-calls","title":"1. FILE CALLS","text":"<pre><code>NAME   :  open\nPURPOSE:  open a file\nARGS   :  (zp) = pathname\n          .A   = file mode (\"r\", \"w\", \"a\", \"W\", or \"A\")\nRETURNS:  .A   = file descriptor number\n          .CS  = error occurred flag\nALTERS :  .X, .Y, errno\n</code></pre> <p>Opens a file.  The name of the file is given by a pointer to a null-terminated string, and may contain device names and pathnames.  The file mode is a PETSCII character.  \"r\" means to open the file for reading, \"w\" means to open the file for writing, and \"a\" means to open the file for appending (writing, starting at the end of the file).  An error will be returned if you attempt to open for reading or appending a file that does not exist, or if you attempt to open for writing a file that does already exist.  On the other hand, calling with the capital letters \"W\" and \"A\" mean to force a write or append if needed, if the file either already exists or does not already exist, respectively.</p> <p>The function returns a file descriptor number, which is a small unsigned integer that is used with other file calls to specify the file that has been opened.  File descriptors numbered 0, 1, and 2 are used for stdin, stdout, and stderr, respectively.  The file descriptor returned will be the minimum number that is not currently in use.  These numbers are system-wide (rather than local to a process as in Unix), and this has some implications for I/O redirection (see the \"aceFileFdswap\" call below).</p> <p>Restrictions: only so many Kernal files allowed to be open on a disk device, and there is a system maximum of open files.  You will get a \"too many files\" error if you ever exceed this limit.  Also, because of the nature of Commodore-DOS, there may be even tighter restrictions on the number of files that can be simultaneously open on a single disk device, resulting in a \"no channel\" error.  Note that this call checks the status channel of Commodore disk drives on each open, so you don't have to (and should not anyway).</p> <p>If the current program exits either by calling \"exit\" or simply by doing the last RTS, all files that were opened by the program and are still open will be automatically closed by the system before returning to the parent program.</p> <pre><code>NAME   :  close\nPURPOSE:  close an open file\nARGS   :  .A   = File descriptor number\nRETURNS:  .CS  = error occurred flag\nALTERS :  .A, .X, .Y, errno\n</code></pre> <p>Closes an open file.  Not much to say about this one.</p> <pre><code>NAME   :  read\nPURPOSE:  read data from an open file\nARGS   :  .X   = File descriptor number\n          (zp) = pointer to buffer to store data into\n          .AY  = maximum number of bytes to read\nRETURNS:  .AY  = (zw) = number of bytes actually read in\n          .CS  = error occurred flag\n          .ZS  = EOF reached flag\nALTERS :  .X, errno\n</code></pre> <p>Reads data from the current position of an open file.  Up to the specified maximum number of bytes will be read.  You should not give a maximum of zero bytes, or you may misinterpret an EOF (end of file).  The buffer must be at least the size of the maximum number of bytes to read.  The data are not interpreted in any way, so it is the programmer's responsibility to search for carriage return characters to locate lines of input, if he so desires. However, for the console the input is naturally divided up into lines, so each call will return an entire line of bytes if the buffer is large enough.  There are no guarantees about the number of bytes that will be returned, except that it will be between 1 and the buffer size.  So, if you wish to read a certain number of bytes, you may have to make multiple read calls.</p> <p>The call returns the number of bytes read in both the .AY register pair and in (zw), for added convenience.  A return of zero bytes read means that the end of the file has been reached.  An attempt to read beyond the end of file will simply give another EOF return.  End of file is also returned in the .Z flag of the processor.</p> <pre><code>NAME   :  write\nPURPOSE:  write data to an open file\nARGS   :  .X   = file descriptor number\n          (zp) = pointer to data to be written\n          .AY  = length of data to be written in bytes\nRETURNS:  .CS  = error occurred\nALTERS :  .A, .X, .Y, errno\n</code></pre> <p>Writes data at the current position of an open file.  For writing to the console device (where many text files will end up being displayed eventually), the following special control characters are interpreted:</p> <pre><code>CODE(hex)   CODE(dec)   NAME   DESCRIPTION\n---------   ---------   ----   -----------\n$07         7           BEL    ring the bell\n$09         9           TAB    move cursor to next 8-char tab stop\n$0a         10          BOL    move cursor to beginning of current line\n$0d         13          CR     go to start of next line (newline)\n$11         17          VT     go down one line (linefeed)\n$14         20          BS     non-destructive backspace\n$93         147         CLS    clear the screen and home the cursor\n</code></pre> <pre><code>NAME   :  seek\nPURPOSE:  seek to the given file position\nARGS   :  .X   = file descriptor number\n          .AY  = new position\nRETURNS:  .CS  = error occurred flag\nALTERS :  .A, .X, .Y, errno\n</code></pre> <p>Seeks to the given file position. Seek call will only work with special device drivers which are actually designed to randomly access files, such as memory-mapped files. see: mmap.</p> <pre><code>NAME   :  aceFileBload\nPURPOSE:  binary load\nARGS   :  (zp) = pathname\n          .AY  = address to load file\n          (zw) = highest address that file may occupy, plus one\nRETURNS:  .AY  = end address of load, plus one\n          .CS  = error occurred flag\nALTERS :  .X, errno\n</code></pre> <p>Binary-load a file directly into memory.  If the file will not fit into the specified space, an error will be returned and the load truncated if the device supports truncation; otherwise, important data may be overwritten.</p> <pre><code>NAME   :  aceFileRemove\nPURPOSE:  delete a file\nARGS   :  (zp) = pathname\nRETURNS:  .CS  = error occurred flag\nALTERS :  .A, .X, .Y, errno\n</code></pre> <p>Delete the named file.</p> <pre><code>NAME   :  aceFileRename\nPURPOSE:  rename a file or directory\nARGS   :  (zp) = old filename\n          (zw) = new filename\nRETURNS:  .CS  = error occurred flag\nALTERS :  .A, .X, .Y, errno\n</code></pre> <p>Renames a file or directory.  If a file with the new name already exists, then the operation will be aborted and a \"file exists\" error will be returned.  On most devices, the file to be renamed must be in the current directory and the new name may not include any path, just a filename.</p> <pre><code>NAME   :  aceFileStat\nPURPOSE:  give information about file\nARGS   :  (zp) = pathname\nRETURNS:  .AY  = size of file in bytes\n          .CS  = error occurred flag\nALTERS :  .A, .X, .Y, errno, aceDirentBuffer\n</code></pre> <p>Reads the directory information for a single file on a virtual drive or floppy. If the file exists, then all the metadata for the file is retrieved and the aceDirentBuffer is filled with that metadata.</p> <pre><code>NAME   :  aceFileIoctl\nPURPOSE:  perform special io-device control operations\nARGS   :  .X   = file descriptor number\n          .A   = flags\nRETURNS:  .A   = device type\n          .X   = columns\n          .Y   = rows\nALTERS :  .A, .X, .Y\n</code></pre> <p>Performs device-specific io-control operations. Current use only with tty type devices to set the rows x columns for the virtual terminal (actually a pseudo-tty running on the RPi).</p>"},{"location":"doc/apiref/#2-directory-calls","title":"2. DIRECTORY CALLS","text":"<pre><code>NAME   :  aceDirOpen\nPURPOSE:  open a directory for scanning its directory entries\nARGS   :  (zp) = directory pathname\nRETURNS:  .A   = file descriptor number\n          .CS  = error occurred flag\nALTERS :  .X, .Y, errno\n</code></pre> <p>This call opens a directory for reading its entries.  It returns a \"file\" descriptor number to you to use for reading successive directory entires with the \"aceDirRead\" call.  The pathname that you give to this call must be a proper directory name like \"a:\" or \"c:2//c64/games/:\", ending with a colon character.  You can have directories from multiple devices open for reading at one time, but you cannot have the directory of one device open multiple times.  Also note that you cannot pass wildcards to this call; you will receive the entire directory listing.is call; you will receive the entire directory listing.</p> <pre><code>NAME   :  aceDirClose\nPURPOSE:  close a directory opened for scanning\nARGS   :  .A   = file descriptor number\nRETURNS:  .CS  = error occurred flag\nALTERS :  .A, .X, .Y, errno\n</code></pre> <p>Closes a directory that is open for reading.  You can make this call at any point while scanning a directory; you do not have to finish scanning an entire directory first.</p> <pre><code>NAME   :  aceDirRead\nPURPOSE:  read the next directory entry from an open directory\nARGS   :  .X   = file descriptor number\nRETURNS:  .Z   = end of directory flag\n          .CS  = error occurred flag\n          aceDirentBuffer = new directory entry data\nALTERS :  .A, .X, .Y, errno\n</code></pre> <p>Reads the next directory entry from the specified open directory into the system interface global variable \"aceDirentBuffer\" described earlier.  After opening a directory for reading, the first time you call this routine, you will receive the name of the disk (or directory).  The \"aceDirentNameLen\" and \"aceDirentName\" fields are the only ones that will contain information; the rest of the fields should be ignored.</p> <p>Each subsequent call to this routine will return the next directory entry in the directory.  All of the \"dirent\" fields will be valid for these.</p> <p>Then, after all directory entries have been read through, the last call will return a directory entry with a null (zero-length) name.  This corresponds to the \"blocks free\" line in a Commodore disk directory listing.  The \"aceDirentBytes\" field for this last entry will be set to the number of bytes available for storage on the disk.  On a Commodore disk drive, this will be the number of blocks free multiplied by 254.  After reading this last entry, you should close the directory.</p> <p>At any time, if something bizarre happens to the listing from the disk that is not considered an error (I don't actually know if this is possible or not), then the .Z flag will</p> <pre><code>NAME   :  aceDirIsdir\nPURPOSE:  determine whether the given pathname is for a file or a directory\nARGS   :  (zp) = pathname\nRETURNS:  .A   = device identifier\n          .X   = is-a-disk-device flag\n          .Y   = is-a-directory flag\n          .CS  = error-occurred flag\nALTERS :  errno\n</code></pre> <p>Given a properly formatted directoryname or filename, this routine will return whether the name is for a file or a directory, whether the device of the file or directory is a disk or character device, and the system identifier for the device.  The two flags return $FF for true and $00 for false.  The device identifier is superfluous for now, but a \"devinfo\" call may be added later.  Note that this call does not necessarily indicate whether the file/directory actually exists or not.</p> <pre><code>NAME   :  aceDirChange\nPURPOSE:  change the current working directory\nARGS   :  (zp) = new directory pathname\n          .A   = home flag ($00=given pathname, $80=goto home directory)\nRETURNS:  .CS  = error occurred flag\nALTERS :  .A, .X, .Y, errno\n</code></pre> <p>Changes the current working directory to the named directory if called with a \"home flag\" value of $00.  Too bad the Commodore Kernal doesn't have a similar call.  Unlike the \"cd\" shell command, the argument has to be a properly formatted directory name.  Note that only directories in native partitions on CMD devices are supported by this command; the 1581's crummy idea of partitions is not supported.</p> <p>If the given \"home flag\" is $80, then this call changes the current working directory back to the \"home\" directory that is defined in the \".acerc\" file as the initial directory.</p> <pre><code>NAME   :  aceDirName\nPURPOSE:  return specified system directory name/search path\nARGS   :  .A   = dir/path: 0=curDir, 1=homeDir, 2=execSearchPath,\n                           3=configSearchPath, 4=tempDir\n          (zp) = string buffer\nRETURNS:  .CS  = error-occurred flag\nALTERS :  .A, .X, .Y, errno\n</code></pre> <p>Returns the null-terminated string for the requested directory or search path.  An argument of 0 means to return the current directory; 1 means to return the home directory; 2, the search path that is used to find executable programs; 3, the search path that is used to find configuration files (usually of the form \".xxxrc\"); and 4, the directory to store temporary files.</p> <p>Actually, search paths (arguments 2 and 3) are really a sequence of null- terminated strings (with each string representing one component of the whole path) terminated with an empty string.  This call should not cause any disk I/O to occur, so it can be called without hesitating about the overhead. The given string-buffer pointer must point to enough storage to hold the result sting(s).  For the current directory, it should be at least 81 characters in length, for the other directories, 32 characters, and for the search paths, 64 characters.</p> <pre><code>NAME   :  aceDirAssign\nPURPOSE:  assign a directory to a virtual drive\nARGS   :  (zp) = pointer to null-terminated path of directory to assign\n          .X   = device to be assigned\nRETURNS:  .CS  = errno\nALTERS :  .A, .X, .Y, errno\n</code></pre> <p>The device number passed in .X can be easily obtained by using the <code>as_device</code> macro to convert a drive letter (lowercase) to the device number.</p> <pre><code>NAME   :  aceDirStat\nPURPOSE:  Get the status of a virtual device\nARGS   :  (zp) = pointer to null-terminated device prefix (e.g. \"c:\", \"d:\", etc.)\n          .A   = $80 to get device mount name or assignment\n               = $00 to get the current directory of the device\nRETURNS:  .CS  = errno\n          aceSharedBuf contains the status string as a full path\nALTERS :  .A, .X, .Y, errno\n</code></pre> <p>You can retrieve the current assignment of a device that has been set in the configuration file or using <code>aceDirAssign</code>. You can also retrieve the full path of an image mounted on a device. For both these uses, pass a value of $80 in .A</p> <p>If you just want the current path of the device, then pass $00 in .A</p> <p>The result is a null-terminated path string in aceSharedBuf.</p>"},{"location":"doc/apiref/#3-screen-control-calls","title":"3. SCREEN-CONTROL CALLS","text":"<p>This section describes the system calls that are available to application programmers for full-screen applications.  These calls are intended to be general enough to handle different screen hardware (the VIC and VDC chips and the VIC soft-80-column bitmap screen, and possibly others).  These calls are also designed to be efficient as possible, to discourage progammers from attempting to bypass using them.  Bypassing these calls would be a bad thing.</p> <p>The calls are designed around the C-128/PET concept of a window.  There is only one active window on the display at a time, which may be is large as the entire screen or as small as a 1x1 character cell.  This window is very cheap to setup and tear down.  An application can have multiple windows on the screen by switching the active window around.</p> <p>In the calls below, all mention \"sw\" in the arguments and return values refer to the \"syswork\" array.  For many calls, there is a \"char/color/ high-attribute\" argument.  This argument determines which parts of a screen location will be modified.  There are three components (bytes) to each screen location: the character code, the color code, and the special-attributes.  The character code is exactly the same as the PETSCII code for the character that you want to display (unlike the screen-code arrangement that Commodore chose).  There are 128 individual characters in the normal PETSCII positions, and 128 reversed images of the characters in the most sensible other positions.  The codes are as follows:</p> <pre><code>CODES (hex)   DESCRIPTION\n-----------   -----------\n$00-$1f       reverse lowercase letters\n$20-$3f       digits and punctuation\n$40-$5f       lowercase letters\n$60-$7f       reverse graphics characters\n$80-$9f       reverse uppercase letters\n$a0-$bf       graphics characters\n$c0-$df       uppercase letters\n$e0-$ef       reverse digits and punctuation\n</code></pre> <p>But note that you can't necessarily count on the reversed characters being present with extended font sets; exotic other characters may be present in those positions instead.</p> <p>There are sixteen color codes, occupying the upper and lower nybbles of the color byte.  The lower nybble specifies the foreground color of the corresponding character, and the upper nybble, the background color.  The VIC and VDC displays don't support background colors per-character, so the background color nybble is always ignored and the screen color is used instead.  The color codes are RGBI codes, as follows:</p> <pre><code>CODE(dec)   (hex)   (bin)   DESCRIPTION\n---------   -----   -rgbi   -----------\n        0      $0   %0000   black\n        1      $1   %0001   dark grey\n        2      $2   %0010   blue\n        3      $3   %0011   light blue\n        4      $4   %0100   green\n        5      $5   %0101   light green\n        6      $6   %0110   dark cyan on VDC, medium grey on VIC-II\n        7      $7   %0111   cyan\n        8      $8   %1000   red\n        9      $9   %1001   light red\n       10      $a   %1010   purple\n       11      $b   %1011   light purple on VDC, orange on VIC-II\n       12      $c   %1100   brown\n       13      $d   %1101   yellow\n       14      $e   %1110   light grey\n       15      $f   %1111   white\n</code></pre> <p>Finally, there are the special-attribute bits.  Not all displays support attributes, and not all displays that support attributes support all of the attributes.  For displays that don't support attributes directly, some other action may be taken instead, like changing the display color, when you use the \"aceWinPut\" call.  The attributes have the following meanings (only four bits are used; the others are ignored but should always be set to zero):</p> <pre><code>BIT VALUE   (dec)   (hex)   DESCRIPTION\n-avub----   -----   -----   -----------\n%10000000     128     $80   alternate characterset (italic)\n%01000000      64     $40   reverse character\n%00100000      32     $20   underline\n%00010000      16     $10   blink\n</code></pre> <p>These values are additive (or, should I say, \"or-ative\"); you can use any combination of them at one time.  Normally, you may wish to leave the high- attribute bits alone, unless you take the values to give them from the color palettes (next section).</p> <p>Most screen operations allow you to select which of character, color, and/or attributes you wish to modify.  Characters and colors can be selected independently of each other, but attributes should only be selected when color is also selected, as colors and attributes generally \"ride together\", although on the soft-80 screen, attributes \"ride with\" the characters. Also, when you select color but not attributes, then attributes are interpreted as if you had selected them but with a value of $00 (all attributes off).  To specify which of you wish to have changed, set bits in the \"char/color/attribute\" argument to system calls.  The flags have the following values.  They are or-ative as well:</p> <pre><code>BIT VALUE   (dec)   (hex)   DESCRIPTION\n-cah-----   -----   -----   -----------\n%10000000     128     $80   modify character\n%01000000      64     $40   modify color\n%00100000      32     $20   modify attribute bits\n</code></pre> <p>The screen calls that deal with placing characters on the screen refer to screen locations using absolute addresses of locations in screen memory. This scheme is used for increased efficiency.  You can obtain information about the absolute screen address of the top left-hand corner of the current window and the number of screen addresses between successive rows, to figure out screen addresses for your applications.  For added convenience, there is a call which will accept row and column numbers and return the corresponding absolute screen address.  Each successive column of a row has an absolute screen address that is 1 higher than the previous, for all displays.</p> <p>The screen-control system calls are as follows:</p> <pre><code>NAME   :  aceWinScreen\nPURPOSE:  set the screen size\nARGS   :  .A   = number of text rows required, minimum\n          .X   = number of text columns required, minimum\nRETURNS:  .A   = number of text rows you get\n          .X   = number of text columns you get\n          .CS  = error occurred flag (requested size cannot be given)\nALTERS :  .Y, errno\n</code></pre> <p>This call selects an appropriate display device, screen, and layout for displaying text.  You ask for the minimum number of rows and columns you require on the screen, and the call returns to you what you receive.  If the system cannot match your minimum requirements, an error will be returned, and the current screen will be unchanged.  The clock speed of the processor will be changed to match the screen selected, if appropriate.  If you pass either number of rows or columns as 0, then the system default value for the current screen type will be used.  If you pass either parameter having value 255, then the system will use the maximum possible value.</p> <pre><code>NAME   :  aceWinMax\nPURPOSE:  set window to maximum size\nARGS   :  &lt;none&gt;\nRETURNS:  &lt;none&gt;\nALTERS :  .A, .X, .Y\n</code></pre> <p>Sets the current window to cover the entire screen.  No errors are possible.</p> <pre><code>NAME   :  aceWinSet\nPURPOSE:  set dimensions of window\nARGS   :  .A   = number of rows in window\n          .X   = number of columns in window\n          sw+0 = absolute screen row of top left corner of window\n          sw+1 = absolute screen column of top left corner of window\nRETURNS:  .CS  = error occurred flag\nALTERS :  .A, .X, .Y, errno\n</code></pre> <p>Sets the current window to the size you specify.  You will get an error return if the window will not fit on the screen or of it does not contain at least one character.  The absolute screen row and column values start from zero.</p> <pre><code>NAME   :  aceWinSize\nPURPOSE:  return dimensions of window\nARGS   :  &lt;none&gt;\nRETURNS:  .A   = number of rows in window\n          .X   = number of columns in window\n          sw+0 = absolute screen row of top left corner of window\n          sw+1 = absolute screen column of top left corner of window\n         (sw+2)= screen address of top left corner\n          sw+4 = screen address increment between successive rows on screen\nALTERS :  &lt;none&gt;\n</code></pre> <p>Returns information about the current window.  The row-increment value is the number of character positions between successive physical rows on the screen.  The increment between successive positions on the same line is always 1.  No errors are possible.</p> <pre><code>NAME   :  aceWinCls\nPURPOSE:  clear window\nARGS   :  .A   = char:$80/color:$40/attribute:$20 modification flags\n          .X   = character fill value\n          .Y   = color fill value\n          sw+6 = attribute fill value\nRETURNS:  &lt;none&gt;\nALTERS :  .A, .X, .Y\n</code></pre> <p>This call \"clears\" the current window by filling it with the character/ color/attributes you specify.  You can use the char/color/attr to limit what gets cleared.</p> <pre><code>NAME   :  aceWinPos\nPURPOSE:  return screen address of given row and col\nARGS   :  .A   = row\n          .X   = column\nRETURNS: (sw+0)= screen memory address of position\nALTERS :  .A, .X, .Y\n</code></pre> <p>Given a row and column in the current window, returns the corresponding absolute screen-memory location for use with other calls.  No errors are checked for or returned, so garbage in, garbage out.</p> <pre><code>NAME   :  aceWinPut\nPURPOSE:  put characters and color onto screen\nARGS   :  .A   = char:$80/color:$40/attribute:$20 modification flags\n          .X   = length of character string\n          .Y   = color\n         (sw+0)= absolute screen address to start putting data at\n         (sw+2)= character string pointer\n          sw+4 = fill character\n          sw+5 = total field length\n          sw+6 = attribute flags\nRETURNS:  &lt;none&gt;\nALTERS :  .A, .X, .Y\n</code></pre> <p>Puts text onto the screen.  The output region is given by the absolute starting screen address and the total field length.  This region must be contained on one line of the current window, or bad things will happen. Alternatively, you can put data to the screen in a region that is completely outside of the current window, provided that it is contained on one physical line of the display.  A pointer to the characters to be printed is given, as well as the length of the character array.  Control characters in this string are ignored; they are poked literally onto the screen, including the null character.  The length of the character string must be less than or equal to the total length of the field.  Remaining spaces in the field will be filled in with the \"fill character\".</p> <p>The color of the total field length will be filled in with \"color\".  You can use the \"char/color/attr\" modification flags to specify what is to be changed.  If you were to, for example, specify that only the characters are to be put (and not colors nor attributes), then the call would execute faster.</p> <pre><code>NAME   :  aceWinGet\nPURPOSE:  get characters and colors from screen into memory\nARGS   :  .A   = char:$80/color:$40/attribute:$20 modification flags\n          .X   = length to get\n         (sw+0)= absolute screen address to start getting from\n         (sw+2)= character-storage pointer\n         (sw+4)= color-storage pointer\n         (sw+6)= attribute-storage pointer\nRETURNS:  &lt;none&gt;\nALTERS :  .A, .X, .Y\n</code></pre> <p>This call fetches characters, colors, and/or attributes from the screen into the memory you specify.  Handling colors and attributes independently is a bit inefficient, but there is no other good way out of this if we want to support many display types.</p> <pre><code>NAME   :  aceWinScroll\nPURPOSE:  scroll window\nARGS   :  .A   = flags: char:$80/color:$40/attribute:$20 + $08=up + $04=down\n          .X   = number of rows to scroll up/down\n          sw+4 = fill character\n          sw+6 = fill attribute\n          .Y   = fill color\nRETURNS:  &lt;none&gt;\nALTERS :  .A, .X, .Y\n</code></pre> <p>Scrolls the contents of the current window up or down.  You can scroll any number of rows at a time.  After scrolling, the bottom (or top) rows will be filled with the fill character and color (the attribute to fill with will always be all off).  You can limit whether the characters and/or colors are to be scrolled by using the \"flags\" byte in the usual way, except that the \"color\" flag also implies that \"attribute\" (since you would not normally want to scroll them separately, and it would be a lot of work).  Scrolling only the characters, for example, will normally be twice as fast as scrolling both characters and attributes.  Whether to scroll up or down is specified also using bits in the \"flags\" field, as indicated in the input arguments above.  If you specify multiple scroll directions in one call, your requests will be carried out, but the screen will end up as it was, with the top and bottom N lines cleared.</p> <pre><code>NAME   :  aceWinCursor\nPURPOSE:  activate/deactivate cursor\nARGS   : (sw+0)= screen address to place cursor\n          .A   = enable flag ($ff=cursor-on / $00=cursor-off)\n          .Y   = color to show cursor in\nRETURNS:  &lt;none&gt;\nALTERS :  .A, .X, .Y\n</code></pre> <p>Displays or undisplays the cursor at the given screen address.  This call returns immediately in either case.  No errors are returned.  Do not display anything in or scroll the window while the cursor is being displayed, do not display the cursor twice, and do not undisplay the cursor twice in a row or bad things will happen.  Actually, the screen-address argument will be ignored if you are undisplaying the cursor, so there is no need to provide it in that case.  When the system starts, the cursor will be in its undisplayed state (duh!).  You also get to specify the color you want the cursor to be shown in.</p> <pre><code>NAME   :  aceWinPalette\nPURPOSE:  get standard color palette for current screen\nARGS   :  &lt;none&gt;\nRETURNS:  sw+0 = main character color\n          sw+1 = cursor color\n          sw+2 = status character color\n          sw+3 = separator character color\n          sw+4 = highlight character color\n          sw+5 = alert character color\n          sw+6 = screen border color\n          sw+7 = screen background color\nALTERS :  .A, .X, .Y\n</code></pre> <p>Returns the palette of colors that are recommended to be used in applications.  These colors are chosen by the user in the system configuration, so they can be interpreted as being what the user wants and expects applications to use.  A different selection is made by the user for each different screen type, and the palette returned will be for the screen type currently in use.  Eight colors are included in the palette, and you may interpret their meaning according to the application.  The suggested usages are given in the return arguments listed above.  I know that a lot of people out there like to use every color available, but there is a point where the use of color stops conveying useful information and starts to look like \"angry fruit salad\".</p> <pre><code>NAME   :  aceWinChrset\nPURPOSE:  set/get character images/palette codes for the current character set\nARGS   :  .A   = flags: $80=put, $40=get, $20=chr/palette, $10=full/rvs,\n                        $08=8-bit, $04=4-bit, $02=main, $01=alternate)\n          .X   = character code/palette position to start from\n          .Y   = number of chars to modify ($00 means 256)\n          (zp) = data pointer\nRETURNS:  .A   = flags: what's available, $10,$08,$04,$02,$01\nALTERS :  .X, .Y\n</code></pre> <p>Description too complicated for me to get into right now. Out flags tells what exists, both put&amp;get means ignore full/rvs. Read the source code for more details.</p> <pre><code>NAME   :  aceWinOption\nPURPOSE:  set/get character window/screen options\nARGS   :  .X   = option number to get/set\n                 (1=screen color, 2=border color, 3=cursor style,\n                  4=cursor-blink speed, 5=screen rvs, 6=cpu speed,\n                  7=alter palette)\n          .CS  = set option (.CC=get)\n          .A   = value\n          .Y   = extra value if needed\nRETURNS:  .A   = return value of option\n          .CS  = error-occurred flag\nALTERS :  .X, .Y, errno\n</code></pre> <p>You can use this call to set/get a number of screen options.  If you call with the carry flag clear, you will only read the option, and if you call with the carry flag set, you will both set and read the new option value. You may not always get the option you wanted to set (because of hardware limitations).  The .X register selects which option is to be set/gotten.  If the call returns with the carry flag set, it means either that you have requested an illegal option/value or that the requested option isn't available for the current screen (errno).</p> <p>Option #1 is the screen color.  The active screen color goes into the lower nybble of the accululator.  Option #2 is the screen border color.  The active color goes into the bottom of the accumulator, but for the VDC screen, which has no border, it will be unchanged and always read as being black.  Option #3 is the cursor style.  The style code goes into the accumulator: $00=flashing block, $01=solid block, $02=flashing underline, $03=solid underline.  The display driver will do the best it can with the screen hardware.  Option #4 is the cursor blink speed, and the flash speed in jiffies goes into the accumulator (the time to flash on and to flash off.  The flash-on and flash-off times are always equal, and equal to the given value).</p> <p>Option #5 is to reverse the screen.  A value of $00 in the accumulator means that the screen isn't reveresed, and a value of $ff means that it is. Option #6 is to set the CPU speed.  Arguably, this option doesn't really belong with the screen drivers, but it's here anyway.  The number of MHz goes into the accumulator.  Option #7 is to read/set the color palette.  The palette position to read/change goes into .Y and the color goes into the accumulator.  The palette changes will be in effect for the current display driver for the full run of the system.</p> <pre><code>NAME   :  aceWinGrChrPut\nPURPOSE:  Put character from graphical set\nARGS   :  .A   = char:$80/color:$40/attribute:$20 modification flags\n          .Y   = color\n         (sw+0)= absolute screen address to start putting data at\n         (sw+2)= character pointer\n         sw+5 = total field length\nRETURNS:  &lt;none&gt;\nALTERS :  .A, .X, .Y\n</code></pre> <p>Output a character from the graphical set. This is used in the toolbox code to draw borders around text, such as in popup menus.</p>"},{"location":"doc/apiref/#4-console-calls","title":"4. CONSOLE CALLS","text":"<p>The calls in this section refer to the system \"console\", which includes the screen and keyboard.  The console-related calls are at a higher level than the calls in the previous section.</p> <pre><code>NAME   :  aceConWrite\nPURPOSE:  write data to console\nARGS   :  (zp) = data to print\n          .AY  = bytes of data to print\n          .X   = initial prescroll &amp; exit mode: $00=off, $01+=presc, $ff=ex-sc\nRETURNS:  .X   = required scrolling: $00=none\n          (zp) = data still to print, if not completed\n          .AY  = bytes still to print, if not completed\nALTERS :  .A, .X, .Y\n</code></pre> <p>This call is the same as the \"write\" system call, except this always writes to the console, and no errors are possible, if you call it with .X==$00.  If .X equals any other value, then the screen will be scrolled up that many rows before printing begins and ... This feature is provided so that console-printing applications can implement scrollback buffers.</p> <pre><code>NAME   :  aceConPutlit\nPURPOSE:  write literal character to console\nARGS   :  .A   = character\nRETURNS:  &lt;none&gt;\nALTERS :  .A, .X, .Y, errno\n</code></pre> <p>This call is the same as \"write\"ing a single character to the console, except that the control characters are not interpreted but are displayed literally instead.</p> <pre><code>NAME   :  aceConPos\nPURPOSE:  set cursor location\nARGS   :  .A   = row\n          .X   = column\nRETURNS:  .CS  = error encountered flag\nALTERS :  .A, .X, .Y\n</code></pre> <p>This call will set the screen location that the next console \"read\" or \"write\" system call will operate from.  If the \"cursor\" position is outside the boundaries of the current window on the screen, an error will be returned.</p> <pre><code>NAME   :  aceConGetpos\nPURPOSE:  get current cursor location\nARGS   :  &lt;none&gt;\nRETURNS:  .A   = row\n          .X   = column\nALTERS :  .Y\n</code></pre> <p>This call returns the current location of the console cursor.</p> <pre><code>NAME   :  aceConInput\nPURPOSE:  inputs a line from the console\nARGS   :  (zp) = input buffer pointer / initial string pointer\n          .Y   = number of characters in initial string\nRETURNS:  .Y   = number of entered characters\n          .CS  = error\nALTERS :  .A, .X\n</code></pre> <pre><code>NAME   :  aceConStopkey\nPURPOSE:  check if stop key is being held down\nARGS   :  &lt;none&gt;\nRETURNS:  .CS  = stop key pressed\nALTERS :  .A, .X, .Y, errno\n</code></pre> <p>Indicates whether the STOP (RUN/STOP) key is currently being held down by the user.  If so, carry flag is set on return (and clear if not).  If the stop key is discovered to be pressed by this call, then the keyboard buffer will also be cleared.</p> <pre><code>NAME   :  aceConGetkey\nPURPOSE:  get a key code from the keyboard buffer\nARGS   :  &lt;none&gt;\nRETURNS:  .A   = keyboard character\n          .X   = shift pattern\nALTERS :  .Y\n</code></pre> <p>Waits for the user to type a key (or takes a previous keystroke from the keyboard buffer).  Regular characters are returned in their regular PETSCII codes, but there are many special control keystrokes.  I still haven't figured out what all of the special codes should be, but all 256 possible character values will be covered.  Special codes like \"page up\", etc. should help in standardizing control keystrokes for applications.  Note that these definitions of keycodes is only suggested; your full-screen application can interpret them however it wants.  The key code is returned in the accumulator.  No errors are possible.</p> <p>The tables below summarize the meanings of the various key codes.  Not all of the C64 keys have been decided yet.  Note that the keys for \"@\" to \"\", used in association with shifting keys, are \"@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^\". (\"\\\" means the Pound key, \"^\" means the Uparrow key, and \"_\" means the Backarrow key). \"CT\" means Control, \"SH\" means Shift, \"AL\" means Alternate, and \"CO\" means Commodore.  On the C64, Alternate is obtained by holding down the Commodore and Control keys simultaneously, and \"CS\" below means to hold down the Commodore and Shift keys simultaneously.  The \"CS\" combination is used to make the functions of keys only provided on the C128's extended keyboard available on the C64.</p> <pre><code>CODE(s)   C128 KEY(s)    C64 KEY(s)     DESCRIPTION\n-------   ------------   ------------   -----------\n$20-$3f   SP to \"?\"      SP to \"?\"      Regular numbers and punctuation\n$40-$5f   \"@\" to \"_\"     \"@\" to \"_\"     Regular lowercase letters\n$60-$7f   AL-@ to AL-_   &lt;undecided&gt;    Alternate keys\n$a0-$bf   CO-@ to CO-_   CO-@ to CO-_   Commodore keys\n$c0       SH-*           SH-*           Back-quote (`)\n$c1-$da   SH-A to SH-Z   SH-A to SH-Z   Regular uppercase letters\n$db       SH-+           SH-+           Left curly brace ({)\n$dc       SH-\\ (Pound)   SH-\\ (Pound)   Vertical bar (|)\n$dd       SH-- (Minus)   SH-- (Minus)   Right curly brace (})\n$de       SH-Uparrow     SH-Uparrow     Tilda (~)\n$df       SH-Backarrow   SH-Backarrow   House character (DEL on most systems)\n$e0-$ff   CT-@ to CT-_   CT-@ to CT-_   Control keys\n\nCODE(s)   C128 KEY(s)    C64 KEY(s)     DESCRIPTION\n-------   ------------   ------------   -----------\n$00       &lt;none&gt;         &lt;none&gt;         &lt;cannot be generated-I may change this&gt;\n$01       CT-RETURN      CT-RETURN      End of file\n$02       SH-TAB         CS-R           Backtab\n$03       STOP           STOP           Stop some operations\n$04       HELP           CS-H           Context-sensitive help\n$05       CT-2           CT-2           White\n$06       SH-LEFT        CS-B           Word left\n$07       SH-LINEFEED    CS-P           Menu exit\n$08       CO-DEL         CO-DEL         Rubout character under cursor\n$09       TAB            CS-T           Tab\n$0a       LINEFEED       CS-L           Menu\n$0b       SH-RIGHT       CS-N           Word right\n$0c       CO-UP          CS-W           Goto top of document\n$0d       RETURN         RETURN         Return\n$0e       SH-ESCAPE      CS-D           Window control\n$0f       CO-DOWN        CS-Z           Goto bottom of document\n$10       CO-LEFT        CS-A           Goto beginning of line\n$11       DOWN           DOWN           Cursor down\n$12       CT-9           CT-9           Rvs\n$13       HOME           HOME           Home\n$14       DEL            DEL            Backspace\n$15       CO-RIGHT       CS-S           Goto end of line\n$16       CT-UP          CS-I           Page up\n$17       CT-DOWN        CS-M           Page down\n$18       CT-TAB         CS-Y           Tab set\n$19       CT-LEFT        CS-J           Page left\n$1a       CT-RIGHT       CS-K           Page right\n$1b       ESCAPE         CS-E           Escape\n$1c       CT-3           CT-3           Red\n$1d       RIGHT          RIGHT          Cursor right\n$1e       CT-6           CT-6           Green\n$1f       CT-7           CT-7           Blue\n\nCODE(s)   C128 KEY(s)    C64 KEY(s)     DESCRIPTION\n-------   ------------   ------------   -----------\n$80       CT-F1          CT-F1          Function key 9\n$81       CO-1           CO-1           Orange/Purple(?)\n$82       CT-F3          CT-F3          Function key 10\n$83       SH-STOP        SH-STOP        Run\n$84       SH-HELP        CS-G           Context-insensitive help\n$85       F1             F1             Function key 1\n$86       F3             F3             Function key 3\n$87       F5             F5             Function key 5\n$88       F7             F7             Function key 7\n$89       SH-F1          SH-F1          Function key 2\n$8a       SH-F3          SH-F3          Function key 4\n$8b       SH-F5          SH-F5          Function key 6\n$8c       SH-F7          SH-F7          Function key 8\n$8d       SH-RETURN      SH-RETURN      &lt;undecided&gt;\n$8e       CT-F5          CT-F5          Function key 11\n$8f       CT-F7          CT-F7          Function key 12\n$90       CT-1           CT-1           Black\n$91       UP             UP             Cursor up\n$92       CT-0           CT-0           Rvs off\n$93       SH-HOME        SH-HOME        Clear screen\n$94       SH-DELETE      SH-DELETE      Insert one space\n$95       CO-2           CO-2           Brown\n$96       CO-3           CO-3           Light red\n$97       CO-4           CO-4           Dark gray\n$98       CO-5           CO-5           Medium gray/dark cyan(?)\n$99       CO-6           CO-6           Light green\n$9a       CO-7           CO-7           Light blue\n$9b       CO-8           CO-8           Light gray\n$9c       CT-5           CT-5           Magenta\n$9d       LEFT           LEFT           Cursor left\n$9e       CT-8           CT-8           Yellow\n$9f       CT-4           CT-4           Cyan\n</code></pre> <p>The shift pattern is recorded when keys are put into the keyboard buffer, and returned in the .X register by this call.</p> <pre><code>BIT VALUE   (dec)   (hex)   DESCRIPTION\n---------   -----   -----   -----------\n%00100000      32     $20   Extended key (C128 / Commodore+Shift on C64)\n%00010000      16     $10   Caps Lock\n%00001000       8     $08   Alternate\n%00000100       4     $04   Control\n%00000010       2     $02   Commodore\n%00000001       1     $01   Shift\n</code></pre> <pre><code>NAME   :  aceConKeyAvail\nPURPOSE:  check if any key is available in the keyboard buffer\nARGS   :  &lt;none&gt;\nRETURNS:  .A   = peeked keyboard character\n          .X   = peeked shift pattern\n          .Y   = keyboard type ($00=basic, $80=extended)\n          .CC  = key is available (.CS if not)\nALTERS :  &lt;none&gt;\n</code></pre> <p>Returns whether a key is available in the keyboard buffer or not in the carry flag.  If there is a key, then the key and the shift pattern will be returned in the .A and .X registers, but not removed from the buffer so that they will be returned on the next \"getkey\" call.</p> <p>The .Y register returns a code indicating what type of keyboard the machine has.  A value of $00 means that only a \"basic\" keyboard is available, and a value of $80 means that an \"extended\" keyboard is in use.  The C64 has a \"basic\" keyboard and the C128 has an \"extended\" keyboard.  However, do not use this routine to tell whether you are running on a C64 or a C128, since alternate keyboards may be supported in the future.</p> <pre><code>NAME   :  aceConMouse\nPURPOSE:  read the buttons and position of the mouse\nARGS   :  &lt;nothing&gt;\nRETURNS:  .A   = mouse-button status: $80=left, $40=right, $20=middle\n          .Y   = mouse-present flag: $80=yes\n         (sw+0)= mouse X position\n         (sw+2)= mouse Y position\nALTERS :  .A, .X, .Y\n</code></pre> <p>Returns the current mouse status see: toolx/pointer.asm.</p> <pre><code>NAME   :  aceConJoystick\nPURPOSE:  read the inputs of the two joysticks\nARGS   :  &lt;nothing&gt;\nRETURNS:  .A   = button mask for joy1: $10=fire,$8=right,$4=left,$2=down,$1=up\n          .X   = button mask for joy2: $10=fire,$8=right,$4=left,$2=down,$1=up\n          .Y   = joysticks present: $80=joy1, $40=joy2\nALTERS :  &lt;nothing&gt;\n</code></pre> <p>The kernel will remap the meanings of \"joy1\" and \"joy2\" according to the system configuration.  You will normally want to use \"joy1\" if you are running a single-joystick application.</p> <pre><code>NAME   :  aceConGamepad\nPURPOSE:  read/configure the inputs of up to two usb gamepad controllers\nARGS   :  .AY = ptr to byte array\n          .CC = read controller\n          .CS = configure controller\nRETURNS:  4-byte array with controller button bits\nALTERS :  .A, .X, .Y\n</code></pre> <p>For reading the controllers, pass a pointer to a 4-byte array in .AY. The first two bytes of the array are for js0 and the last two bytes are for js1. For each gamepad, the low-order nybble of the low-order byte has the direction (e.g. D-pad) bits, and the high-order byte has the bits for the 8 supported buttons. The buttons are translated through a configuration option specific to each gamepad. Configuration is done in the idun-shell using the 'joys' command.</p> <p>The mapping of the standard directions/buttons to the value returned from this procedure is as follows:</p> <pre><code>button X    X    X    X  Left Right Up  Down Strt Sel L-Tr  R-Tr  Y    X    B    A\nbit   15   14   13   12   11   10   9    8    7    6    5    4    3    2    1    0    \n</code></pre> <p>In the case of configuring a gamepad, the carry-bit must be set, and the returned values are button numbers rather than a bitmask. For more details, see: cmd/joys.asm.</p> <pre><code>NAME   :  aceConOption\nPURPOSE:  read/modify console configuration settings\nARGS   :  .X=option from list below\n          .A=new value (if modify)\n          .CS=set/modify value\nRETURNS:  .A=current value -or- .zp pointer value\nALTERS :  .A, .X\n</code></pre> <p>1=console-put mask, 2=character color, 3=character attributes, 4=fill color, 5=fill attribute, 6=cursor color, 7=force cursor wrap, 8=shift-keys for scrolling, 9=mouse scaling, 10=key-repeat delay, 11=key-repeat rate, 12=prescrool override, 13=screensaver timeout, 14=screensaver tool (zp), 15=default shell (zp)</p> <pre><code>NAME   :  aceConPutchar\nPURPOSE:  put single character to console output\nARGS   :  .A   = character                \nRETURNS:  &lt;none&gt;\nALTERS :  .A, .X, .Y\n</code></pre> <pre><code>NAME   :  aceConPutctrl\nPURPOSE:  put control character to console output\nARGS   :  .A   = control char.\n          .X   = optional parameter\nRETURNS:  &lt;none&gt;\nALTERS :  .A, .X, .Y\n</code></pre> <pre><code>NAME   :  aceConSetHotkeys\nPURPOSE:  set a handler for hotkeys input to the console\nARGS   :  .AY = pointer to the handler\nRETURNS:  &lt;none&gt;\nALTERS :  .A, .Y\n</code></pre> <p>Normally setup by the toolbox so that applications can easily set/restore hotkey mappings (see: toolbox.md). Set .AY to $0000 to disable.</p>"},{"location":"doc/apiref/#5-graphics-calls","title":"5. GRAPHICS CALLS","text":"<p>** UNDER CONSTRUCTION ** (see: toolx/gfx.asm)</p>"},{"location":"doc/apiref/#6-process-control-calls","title":"6. PROCESS-CONTROL CALLS","text":"<p>This section describes calls that are used to control the execution of processes (active programs).  From within one program, you can call for the execution of another program, have it execute, and then return to the calling program.  Since only one program is allowed in memory at a time, some special problems arise.</p> <pre><code>NAME   :  aceProcExec\nPURPOSE:  execute external program as a child process\nARGS   :  (zp) = program name of executable\n          (zw) = start address of argument vector\n          .AY  = number of arguments\n          .X   = reload from file or volatile storage (pages+, $00=file)\n          [mp] = pointer to far memory volatile storage\n         [sw+0]= \"std\" file redirections\nRETURNS:  .A   = exit code\n          .X   = number of bytes in \"aceExitData\" used\n          (zp) = given argument count\n          (zw) = given argument vector pointer\n          [mp] = pointer to far memory volatile storage\n          .CS  = error occurred flag\nALTERS :  .Y, errno\n</code></pre> <p>Calling this routine will cause a new \"frame\" to be set up on the \"system stack\" (lowering the available application area memory a little), the specified program to be loaded into memory over top of the current one, the new program to be executed, the old program to be reloaded from whatever disk unit it came from originally upon exit of the new program, and control to be returned to the old process with the return values from the executed program.  This is a complicated procedure and many things can go wrong.</p> <p>The first thing that a process that wants to call another program must do is set up the arguments to be passed in.  All arguments must be null-terminated strings.  These arguments are to be put into high memory, starting from one less than the location pointed to by \"aceMemTop\" and working downward.  It does not matter in which order the strings are placed, as long as they are all grouped together.  Then, immediately below the strings comes the vector of two-byte RAM0 pointers that point to the strings.  This array must be in order, with the lowest entry pointing to the first (zero subscript) string, etc., the second highest entry pointing to the last string, and the highest entry containing the value $0000.  An asciigram follows:</p> <pre><code>  HIGHER ADDRESSES\n|           |\n|           | &lt;--(aceMemTop)\n+-----------+\n|           |\n| string    |\n|           |         : collection of null-terminated strings\n|  contents |\n|           |\n|           |\n+-----------+\n|   $0000   |         : argv[N] : null argument pointer\n+-----------+\n| strptrN-1 |         : argv[N-1]\n+-----------+\n| strptrN-2 |         : argv[N-2]\n+-----------+\n.           .\n.           .\n+-----------+\n| strptr 1  |         : argv[1] : first actual argument\n+-----------+\n| strptr 0  | &lt;--(zw) : argv[0] : filename of program to be executed\n+-----------+\n|           |\n  LOWER ADDRESSES\n</code></pre> <p>The first entry should indicate the filename or command name of the program being executed, and the subsequent arguments are the actual input arguments to the program being called.  The address of the first argument vector table entry is loaded into (zw), and the number of arguments is loaded into .AY. Note that this value also includes the command name, so if, for example, you were to call program \"wc\" to count two filenames \"hello\" and \"goodbye\", then you would pass an argument count of 3.  The name pointed to by \"argv[0]\" does not actually have to be the literal command name, but the one pointed to by (zp) does.  If a relative executable name is given in (zp), then the search path will be used to locate the executable.  Oh, don't screw up the organization of the arguments or bad things will happen; there is no structure checking.</p> <p>After setting up the arguments, you'll want to set up any redirections of stdin, stdout, or stderr you'll be needing.  Because there is only one open file table in the whole uni-tasking system, you'll have to manipulate existing entries using the \"aceFileFdswap\" system call described earlier. The open file table is inherited by the child process.  Note that if it closes any of the open files it inherited, then they are also closed to your use also.  If the child accidentally leaves open any files it opened, they will be closed by the system before you are reactivated.</p> <p>Finally, before the call is made, you have to save any volatile local information into \"far\" memory.  All application zeropage and application area memory will be modified by the called program, so you must save whatever you will need to continue after the return to be able to continue. As mentioned earlier, all of the \"far\" memory that a parent program owns will be safe, so you can save your volatile information there, in any format you wish.  All you have to do is save the pointer to the far memory into the [mp] pointer.  Upon return of the child process, the value you put into [mp] will be restored, and you can then restore your volatile information out of far storage.  If you wish to save no volatile information, then you can just leave garbage in the [mp] value, since it will not be interpreted by the system.</p> <p>Alright, so now you call the \"aceProcExec\" primitive, the child program is loaded, executed, and it returns.</p> <p>At this time, the parent program (that's you) is reloaded from wherever it was loaded originally and you are returned to the instruction immediately following the \"jsr aceProcExec\", with your processor stack intact but the rest of your volatile storage invalid.  Even if there is an error return (carry flag set), your volatile storage will still need to be restored, since the application area may have been overwritten before the error was discovered.  In the case of an error return, the child process will not have been executed.  If the system is unable to reload the parent program (you), then an error return is given to your parent, and so on, as far back as necessary.  (This is a minor exception to the rule that an error return indicates that a child didn't execute; in this case, the child didn't complete).</p> <p>You are also returned an \"exit code\", which will have application-specific meaning, although standard programs (e.g., shell script) interpret the value as: 0==normal exit, anything else==error exit.  The X register is also set to indicate the amount of \"aceExitData\" that is used, to allow for more complicated return values.</p> <pre><code>NAME   :  aceProcExecSub\nPURPOSE:  execute internal subroutine as a separate process\nARGS   :  (zp) = address of subroutine\n          (zw) = address of argument vector\n          .AY  = argument count\n          [mp] = far-memory pointer\n         [sw+0]= \"std\" file redirections\nRETURNS:  .A   = exit code\n          .X   = number of bytes in \"aceExitData\" used\n          (zp) = given argument count\n          (zw) = given argument vector pointer\n          [mp] = given far-memory pointer\n          .CS  = error occurred flag\nALTERS :  .Y, errno\n</code></pre> <p>This call is very similar to \"exec\", except that it calls an internal subroutine rather than an external program.  Thus, you don't have to save or restore your volatile storage, or worry about loading the child or reloading the parent.  You do, however, set up the arguments and file redirections as you would for a full \"aceProcExec\".</p> <pre><code>NAME   :  aceProcExit\nPURPOSE:  exit current program, return to parent\nARGS   :  .A   = exit code\n          .X   = number of bytes in \"aceExitData\" used\nRETURNS:  &lt;there is no return, brah-ha-ha-ha-ha-ha!!!&gt;\nALTERS :  &lt;don't bloody well matter to the caller&gt;\n</code></pre> <p>This call causes the current program to exit back to its parent. A program that exits simply by returning to its environment will give back an exit code of 0, which should be interpreted as a normal return.  If you wish to indicate a special return, you should use some exit code other than zero. Many utilities will interpret non-zero error codes as actual errors and may abort further operations because of this.</p> <p>You may set up a return data in \"aceExitData\", up to 255 bytes worth, and load the number of bytes used into .X if you wish.  It is recommended that the first field of this data be a special identifier code so programs that cannot interpret your data will not try.  You cannot give any far pointers in your return data, since all far memory allocated to you will be freed by the system before returning to your parent.</p>"},{"location":"doc/apiref/#7-memory-calls","title":"7. MEMORY CALLS","text":"<p>The calls given in this section are to be used for accessing \"far\" memory in ACE, which includes all REU, RAMLink, RAM1 and above, and sections of RAM0 that are not in the application program area.  Applications are not allowed to access \"far\" memory directly, because the practice of bypassing the operating system would undoubtedly lead to serious compatibility problems (can you say \"MS-DOS\"?).</p> <p>All of these calls use a 32-bit pointer that is stored in the zero-page argument field \"mp\" (memory pointer).  This field is to be interpreted as consisting of low and high words.  The low word, which of course comes first, is the offset into the memory \"bank\" that is contained in the high word.  Users may assume that offsets within a bank are continuous, so operations like addition may be performed without fear on offsets, to access subfields of a structure, for example.  You may not, however, make any interpretation of the bank word.  An application should only access far memory that it has allocated for itself via the \"aceMemAlloc\" call.</p> <pre><code>NAME   :  aceMemZpload\nPURPOSE:  load zeropage storage from far memory\nARGS   :  [mp] = source far memory pointer\n          .X   = destination zero-page address\n          .Y   = transfer length\nRETURNS:  .CS  = error occurred flag\nALTERS :  .A, .X, .Y, errno\n</code></pre> <p>Load zero-page locations with the contents of far memory.  \"mp\", of course, gives the address of the first byte of far memory to be retrieved.  The X register is loaded with the first address of the storage space for the data on zero page.  It must be in the application zero-page space.  The Y register holds the number of bytes to be transferred, which, considering that transfers must be to the application zero-page storage, must be 126 bytes or less.  This routine will return a \"reference through null pointer\" if [mp] contains a null pointer.</p> <pre><code>NAME   :  aceMemZpstore\nPURPOSE:  store zeropage data to far memory\nARGS   :  .X   = source zero-page address\n          [mp] = destination far memory pointer\n          .Y   = transfer length\nRETURNS:  .CS  = error occurred flag\nALTERS :  .A, .X, .Y, errno\n</code></pre> <p>This routine is the complement of \"zpload\"; this transfers data from zero page to far memory.  The arguments and restrictions are the same as \"zpload\".</p> <pre><code>NAME   :  aceMemFetch\nPURPOSE:  load near RAM0 storage from far memory\nARGS   :  [mp] = source far memory pointer\n          (zp) = destination RAM0 pointer\n          .AY  = transfer length\nRETURNS:  .CS  = error occurred flag\nALTERS :  .A, .X, .Y, errno\n</code></pre> <p>This routine will fetch up to 64K of data from far memory into RAM0 memory where it can be accessed directly by the processor.  The arguments should mostly speak for themselves.  You should not fetch into RAM0 memory that is not specifically allocated to the application.  You will get an error if you try to use a null far pointer.</p> <pre><code>NAME   :  aceMemStash\nPURPOSE:  store near RAM0 data to far memory\nARGS   :  (zp) = source RAM0 pointer\n          [mp] = destination far memory pointer\n          .AY  = transfer length\nRETURNS:  .CS  = error occurred flag\nALTERS :  .A, .X, .Y, errno\n</code></pre> <p>This is the complement of \"fetch\" and operates analogously, except that it transfers data from RAM0 to far memory.</p> <pre><code>NAME   :  aceMemAlloc\nPURPOSE:  allocate pages of far memory to current process\nARGS   :  .A   = requested number of pages to be allocated\n          .X   = starting \"type\" of memory to search\n          .Y   = ending \"type\" of memory to search, inclusive\nRETURNS:  [mp] = far memory pointer to start of allocated memory\n          .CS  = error occurred flag\nALTERS :  .A, .X, .Y, errno\n</code></pre> <p>This routine allocates a given number of contiguous far-memory pages for use by the application, and returns a pointer to the first byte of the first page.  On calling, the accumulator contains the number of pages to allocate (a page is 256 contiguous bytes aligned on a 256-byte address (i.e., the low byte of a page address is all zeros)).</p> <p>The X and Y registers contain the start and end \"types\" of far memory to search for the required allocation.  The possible types are mentioned in the System Constants section.  The numeric values for the \"aceMem\" constants are arranged in order of accessing speed.  So, if your application has speed requirements that dictate, for example, that RAMLink memory should not be used, then you would call \"aceMemAlloc\" with a search range of .X=0 to .Y=aceMemInternal.  If you wanted to say you are willing to accept any memory the system can give to you, you would specify .X=0 to .Y=255.  The values of 0 and 255 will be converted to the fastest and slowest memory available.  Idun will give you the fastest type of memory, from what you specify as acceptable, that it can.</p> <p>This routine will then search its available free memory for a chunk fitting your specifications.  If it cannot find one, the routine will return a \"insufficient memory\" error and a null pointer.  Note that this error may occur if there is actually the correct amount of memory free but just not in a big enough contiguous chunk.  If successful, this routine will return in \"mp\" a pointer to the first byte of the first page of the allocated memory.</p> <p>If you call a subprogram with the \"aceProcExec\" call while the current program is holding far memory, that far memory will be kept allocated to your program and will be safe while the child program is executing.  If you don't deallocate the memory with \"aceMemFree\" before exiting back to your parent program, then the system will automatically deallocate all memory allocated to you.  So, have no fear about calling \"exit\" if you are in the middle of complicated far memory manipulation when a fatal error condition is discovered and you don't feel like figuring out what memory your program owns and deallocating it.</p> <p>Some applications will want to have the most amount of memory to work with, and if there is free space in the application program area that the program is not using directly, then you may want to use that as \"far\" memory.  To do this, you will need to write your own stub routines that manage page allocation and deallocation requests to the near memory, and calls the \"aceMemAlloc\" and \"aceMemFree\" routines to manage the far memory.  Please note that you CANNOT simply free the unused memory of the application program area and expect the system to manage it.  Bad stuff would happen.</p> <p>Some applications will want to have a byte-oriented memory allocation service rather than a page-oriented service.  You can build a byte-oriented service on top of the page-oriented service in your application programs that manage memory for the application and ask the system for pages whenever more memory is required by the application.  Note that this still means that allocated memory will be freed automatically when an application exits.  The \"sort\" program implements this byte-oriented service, so you can check its source code to see how this is done (or to simply cut and paste the code into your own program).</p> <pre><code>NAME   :  aceMemFree\nPURPOSE:  free pages of far memory allocated to current process\nARGS   :  [mp] = far memory pointer to start of memory to be freed\n          .A   = number of pages to be freed\nRETURNS:  .CS  = error occurred flag\nALTERS :  [mp], .A, .X, .Y, errno\n</code></pre> <p>This deallocates memory that was allocated to a process by using the \"aceMemAlloc\" system call.  You will get an error return if you try to deallocate memory that you don't own.</p> <pre><code>NAME   :  aceMemStat\nPURPOSE:  get \"far\" memory status plus process id\nARGS   :  .X   = zero-page address to store status information\nRETURNS:  .A   = current process id\n         [.X+0]= amount of \"far\" memory free\n         [.X+4]= total amount of \"far\" memory\nALTERS :  .X, .Y\n</code></pre> <p>This call returns the current process id, the number of bytes of far memory currently free, and the total amount of far memory.</p>"},{"location":"doc/apiref/#8-time-calls","title":"8. TIME CALLS","text":"<pre><code>NAME   :  aceTimeGetDate\nPURPOSE:  get the current date and time\nARGS   : (.AY) = address of buffer to put BCD-format date into\nRETURNS:  &lt;none&gt;\nALTERS :  .A, .X, .Y\n</code></pre> <p>Returns the current date and time in the BCD format described in the paragraph on \"aceDirentDate\".  It puts it into the at-least-eight-byte storage area pointed to by (.AY).</p> <pre><code>NAME   :  aceTimeSetDate\nPURPOSE:  set the current date and time\nARGS   : (.AY) = address of date in BCD format\nRETURNS:  &lt;none&gt;\nALTERS :  .A, .X, .Y\n</code></pre> <p>Sets the current date and time in the system.  (.AY) points to the BCD date string whose format is discussed in the paragraph on \"aceDirentDate\".  No validity checking is performed on the date given.</p>"},{"location":"doc/apiref/#9-tty-access-calls","title":"9. TTY ACCESS CALLS","text":"<p>Any Idun device that is configured with \"type=6\" is available as a stream device. A stream can be used directly by this simple API, to send/receive bulk data to/from the endpoint. Thes devices are accessed using the \"open\" API. Impotantly, once such a device has been opened, all I/O via the idun-cartridge will be only with this streaming device; so, no I/O with, for example, a virtual drive, can be done until this stream is closed by calling the \"close\" API on its file descriptor.</p> <pre><code>NAME   :  aceTtyAvail\nPURPOSE:  get count of bytes that may be immediately read\nARGS   :  &lt;none&gt;\nRETURNS:  .A   = count\nALTERS :  .A\n</code></pre> <p>Returns a value from 0-255, where zero means no data is available.</p> <pre><code>NAME   :  aceTtyGet\nPURPOSE:  receive up to 256 bytes from stream\nARGS   :  (.AY) = address of receive buffer\n          .X    = number of bytes to receive (1-256), with 256 indicated by a zero\nRETURNS:  &lt;none&gt;\nALTERS :  .A, .X, .Y\n</code></pre> <p>Copies all available data, up to the length given, into the buffer. If no data is available, then it will block until some data arrives.</p> <pre><code>NAME   :  aceTtyPut\nPURPOSE:  send up to 256 bytes to stream\nARGS   :  (.AY) = address of send buffer\n          .X    = number of bytes to send (1-256), with 256 indicated by a zero\nRETURNS:  &lt;none&gt;\nALTERS :  .A, .X, .Y\n</code></pre> <p>Copies specified number of bytes to the stream output. Always non-blocking.</p>"},{"location":"doc/apiref/#10-new-memory-api-for-eram","title":"10. NEW MEMORY API FOR ERAM","text":"<p>This new memory API simplifies the use of both local extended memory and ERAM. It sits atop the normal far memory allocation routines (aceMemAlloc, aceMemStash, etc.). But rather than using far pointers to keep track of the memory blocks, they are usually assigned unique hashtags. These names can be filenames, thus providing a \"memory-mapped file\" feature for super-fast access to runtime data with easy load/save to the filesystem. The idun-shell <code>resident</code> command, as an example, uses this API to keep frequently used commands in memory.</p> <p>Any memory block will occupy from 256 up to 65,280 bytes with storage using full page boundaries. Only a single byte \"Pearson Hash\" value is used to identify the block internally, so locating any one of the up to 256 blocks is very fast. Hash collisions are possible, but unlikely, and attempts to allocate a block that matches an existing hash value will return an error.</p> <p>All of these routines preferentially allocate from ERAM. Local Banked RAM is used only if ERAM is not supported or disabled in the configuration file.</p> <pre><code>NAME   :  new\nPURPOSE:  allocate memory block and fill from local memory\nARGS   :  (.AY) = pointer to local data\n          (zw)  = size of block in bytes\n          .X    = if $ff, then use system memory\nRETURNS:  .CS, errno, mp\nALTERS :  .A, .X, .Y\n</code></pre> <p>If (.AY) is $0000, then this call allocates the block of size (zw) and initializes it with zeroes. Otherwise, the data in local memory at (.AY) is copied to the allocated block.</p> <p>If .X=$ff, then the memory block is allocated out of the system memory area, which is the high blocks of ERAM. This memory is not removed by garbage collection. Therefore, memory in this area is long-lived and can be shared by different processes.</p> <pre><code>NAME   :  mmap\nPURPOSE:  map a file into a block of expansion RAM\nARGS   :  (.AY)= tag name for the memory block (null-terminated)\n          (zp) = pointer to filename\n          .X   = if $ff, then use system memory\nRETURNS:  .CS  = error occurred flag, errno, mp\nALTERS :  .A, .X, .Y\n</code></pre> <p>This routine is for mapping files into ERAM, such that the file's contents are easily read into a working memory buffer. This memory can be treated as a read-only, random-access file, when opened as <code>_:hashtag</code>. Opening a file with this naming convention will try to locate the file in ERAM, and will return a file descriptor (Fd) that can be used with the standard file I/O functions - <code>read</code>, <code>seek</code>, <code>close</code>.</p> <p>It is noteworthy that when used with ERAM, this routine directly loads the file into the memory of the cartridge and is nearly instant.</p> <pre><code>NAME   :  memtag\nPURPOSE:  allocated memory is paired with a hashtag\nARGS   :  (.AY) = tag name for the memory block (null-terminated)\n          (zw)  = size of block in bytes\n          (mp)  = far pointer to block\nRETURNS:  .CS, errno\nALTERS :  .A, .X, .Y\n</code></pre> <p>This routine allows any allocated block to work as if it was created with <code>mmap</code>. The hashtag is assigned to the memory, and then it can be accessed via the File API too.</p>"},{"location":"doc/apiref/#11-miscellaneous-calls","title":"11. MISCELLANEOUS CALLS","text":"<pre><code>NAME   :  aceIrqHook\nPURPOSE:  Hook the kernel IRQ handler\nARGS   :  (.AY) = pointer to custom handler\nRETURNS:  &lt;nome&gt;\nALTERS :  &lt;none&gt;\n</code></pre> <p>The kernel has its own IRQ handler that triggers every 1/60th second. This API allows an application to hook an additional handler to also be called at this same rate. Note: if you just need to trigger a callback after some elapsed time, use the toolbox \"tmo\" calls that exist for this purpose instead.</p> <pre><code>NAME   :  aceMiscSysType\nPURPOSE:  get system model and memory\nARGS   :  &lt;none&gt;\nRETURNS:  .A   = $80/$40 indicates C128/C64 mode, respectively\n          .X   = number of internal 64KB RAM banks (1-4)\n          .Y   = number of 64KB REU banks (4-255)\n          sw+0 = size of VDC memory\nALTERS :  .A, .X, .Y\n</code></pre> <pre><code>NAME   :  aceMiscRobokey\nPURPOSE:  send keystroke to the idun-shell, as if typed\nARGS   :  .A   = keycode\nRETURNS:  &lt;none&gt;\nALTERS :  .A, .X\n</code></pre> <pre><code>NAME   :  aceMiscDeviceInfo\nPURPOSE:  get disk device type &amp; attributes\nARGS   :  (zp) = pointer to filename path\nRETURNS:  .A   = IEC device address\n          .X   = idun device type (1-8)\n          sw+0 = idun device config flags (--dcrush)\n          sw+1 = idun device index\n          .CS  = is a virtual drive?\nALTERS :  .A, .X, .Y\n</code></pre> <pre><code>NAME   :  aceRestart\nPURPOSE:  restart system in one of four manners\nARGS   :  .A   = restart flag\n          .X   = device type, if loading a prg\n          (zp) = pointer to app/prg filename\nRETURNS:  &lt;never&gt; returns!\nALTERS :  &lt;yep&gt;\n</code></pre> <p>This is the only kernel API call which does not return, since it will restart the computer running something else. The flag passed in .A is any one of the defined restart flags: aceRestartWarmReset, aceRestartExitBasic, aceRestartApplReset, or aceRestartLoadPrg. The difference between exiting to BASIC vs. a warm reset is simply whether you get to BASIC with or without a software reset of the CPU. The other two options are used to load an alternative application over top of the idun-shell (aceRestartApplReset) or to load a native C128 application and start it (aceRestartLoadPrg). In this final case, it is critical to set the .X value to \"1\" if the program is being loaded from a floppy disk device. Otherwise, it is assumed to be loaded via the idun-cartridge using a virtual drive.</p> <pre><code>NAME   :  aceMapperCommand\nPURPOSE:  cause memory-mapper to execute pre-defined command\nARGS   :  .X   = command id\n          .A   = command parameter\nRETURNS:  &lt;none&gt;\nALTERS :  .A, .X, .Y\n</code></pre> <p>A lot of the functionality of the idun-cartridge is implemented by running arbitrary 6502 code within a non-maskable interrupt (NMI). These two aceMapper APIs allow an Idun application to invoke this process by specifying system or user-defined commands. For a list of available commands, see the <code>sys</code> and <code>usr</code> APIs of luaref.md.</p> <pre><code>NAME   :  aceMapperProcmsg\nPURPOSE:  receive arbitrary message from memory-mapper\nARGS   :  (.AY) = pointer to callback that processes the message\nRETURNS:  &lt;none&gt;\nALTERS :  .A, .X, .Y\n</code></pre> <p>When this returns, the full message has been processed. It will invoke the callback as many times as needed to process all the data.</p> <pre><code>NAME   :  aceViceEmuCheck\nPURPOSE:  determine if we are running in the vice emulator\nARGS   :  &lt;none&gt;\nRETURNS:  .ZS = emulator detected\nALTERS :  .A\n</code></pre> <p>The memory-mapper functionality works in the emulator, but relies on this API to know whether real NMI interrupts are possible. In the emulator, these are simulated.</p> <pre><code>NAME   :  aceMiscUtoa\nPURPOSE:  convert unsigned 32-bit number to a decimal PETSCII string\nARGS   :  .A   = minimum length for return string\n          .X   = zero-page address of 32-bit number\n          (zp) = pointer to string buffer to store string\nRETURNS:  .Y   = length of string\nALTERS :  .A, .X\n</code></pre> <p>This is a utility call in the kernel.  It is really not necessary for it to be in the kernel, but so many programs make use of it that it makes sense for it to be factored out.  You give a pointer to a 32-bit unsigned value in zero page memory, a pointer to a buffer to store that string that is at least as long as necessary to store the value plus the null-character terminator that will be put on the end of the string, and a minimum length value for the string.  If the number requires fewer digits than the minimum length, the string will be padded with spaces on the left.  Since a 32-bit quantity can only contain an maximum of ten decimal digits, the string buffer will only need to be a maximum of eleven bytes in size.</p> <pre><code>NAME   :  aceMiscIoPeek\nPURPOSE:  do a peek into the I/O space ($D000-$DFFF)\nARGS   :  (zw) = I/O-space address\n          .Y   = offset from (zw)\nRETURNS:  .A   = peeked value\n          .CS  = error if operation not supported\nALTERS :  &lt;nothing&gt;\n</code></pre> <p>Does a peek into the system I/O-address space.  This is a pretty ugly call, but you should use this rather than peeking into the space directly because application programs aren't supposed to directly peek into there at all.</p> <pre><code>NAME   :  aceMiscIoPoke\nPURPOSE:  do a peek into the I/O space ($D000-$DFFF)\nARGS   :  (zw) = I/O-space address\n          .Y   = offset from (zw)\n          .A   = value to poke\nRETURNS:  .CS  = error if operation not supported\nALTERS :  &lt;nothing&gt;\n</code></pre> <p>Does a poke into the system I/O-address space.  This is a pretty ugly call, but you should use this rather than poking into the space directly because application programs aren't supposed to directly peek into there at all.</p>"},{"location":"doc/apiref/#12-ioctl-calls","title":"12. IOCTL CALLS","text":"<p>Idun virtual floppies can be mounted, or their contents accessed on a sector-by-sector basis, using these APIs.</p> <pre><code>NAME   :  aceMountImage\nPURPOSE:  mount a disk image file\nARGS   :  (zp) = pointer to null-terminated image filename\n          .A   = R/W flag\n          .X   = device to mount image\nRETURNS:  .CS  = errno\nALTERS :  .A, .X, .Y, errno\n</code></pre> <p>Idun currently supports .D64, .D71, and .T64 image files, and will likely add others. This API mounts an image file to a virtual drive, just as is done with the <code>mount</code> command in the shell. Set the .A flag to either \"R\" (for read-only) or \"W\" (for read/write) access to the mounted image. The device number passed in .X can be easily obtained by using the <code>as_device</code> macro to convert a drive letter (lowercase) to the device number.</p> <pre><code>NAME   :  aceDirectRead\nPURPOSE:  read a sector from a virtual floppy\nARGS   :  .A   = number of sectors to read\n          .X   = file descriptor of open direct channel\n          (zp) = pointer to buffer\nRETURNS:  .AY  = number of bytes read\n          .CS, errno\nALTERS :  .A, .X, .Y\n</code></pre> <p>See source code for the diskcopy command for an example.</p> <pre><code>NAME   :  aceDirectWrite\nPURPOSE:  write a sector to a virtual floppy\nARGS   :  .A   = number of sectors to write\n          .X   = file descriptor of open direct channel\n          (zp) = pointer to buffer\nRETURNS:  .CS, errno\nALTERS :  .A, .X, .Y\n</code></pre>"},{"location":"doc/apiref/#user-program-organization","title":"USER-PROGRAM ORGANIZATION","text":"<p>The Idun system itself is written using the ACME assembler, so it is recommended that applications be written in this also. Programs for Idun have a very simple structure. Below is the standard \"hello, world\" example program written for the ACME assembler:</p> <pre><code>!source \"sys/acehead.asm\"\n!source \"sys/toolhead.asm\"\n!to \"hello\", plain\n\n* = aceToolAddress\n\njmp main\n!byte aceID1,aceID2,aceID3\n!byte 64,0 ;*stack,reserved\n\nmain = *\n   lda #&lt;helloMsg\n   ldy #&gt;helloMsg\n   sta zp+0\n   sty zp+1\n   lda #&lt;helloMsgEnd-helloMsg\n   ldy #&gt;helloMsgEnd-helloMsg\n   ldx #stdout\n   jsr write\n   rts\n\nhelloMsg = *\n   !pet \"Hello, cruel world.\", chrCR\nhelloMsgEnd = *\n</code></pre> <p>This would normally be put into a file called \"hello.asm\". First thing this program does is include the \"acehead.asm\" file. This is the ACME-assembler file that contains the header information declarations required to access the Idun system interface. Many programs will also inclode \"toolhead.asm\", which is the interface to the toolbox API (see: toolbox.md). Next line gives the starting address to start assembling to; it must be \"aceToolAddress\", which is the address that Idun will load the program. Next line is a directive to the assembler to write the executable code to a \"plain\" binary file named \"hello\". Tools that run from the idun-shell should never have a two-byte header to specify their loading address in the way that Commodore PRG files do.</p> <p>The next eight bytes of object code (which are the first eight bytes of a loaded program) describe the header required by Idun programs.  The first three bytes must be a JMP to the main routine of the program.  The next three bytes must have the values \"aceID1\", \"aceID2\", and \"aceID3\", respectively.  The next two bytes are the minimum stack requirements and flags, respectively.  The stack requirement is for the processor stack, and Idun will make sure your program has at least this much space before your program starts.  The flags field is currently undefined, but you must give it a value of 0.  And that's all there is to it.  The rest of the program can be organized however you want it to be.</p> <p>In this example, we set up the arguments for the \"write\" system call to print the string \"Hello, cruel world.\" plus a carriage return to standard output. Note that this string does not need a terminating null ($00) character since the write call takes a buffer length.  The program then returns to its calling environment via an RTS.  This will cause an implied \"exit(0)\" to be performed by the system, returning to the parent program.</p> <p>Although this program does not take advantage of this, an application program may use zero-page locations $0002 through $007f for storage without fear of having the storage trodden upon by the system.</p> <p>Finally, an application program starts at location \"aceToolAddress\" (plus six) and is allowed to use memory all the way up to one byte less than the address pointed to by \"aceMemTop\" for its own purposes.  Currently, this amount of space is on the order of magnitude of about 24K.  This will be increased in the future.</p> <p>Application programs are not to access I/O features or even change the current memory configuration during execution.  All I/O and other unusual contortions must be performed by Idun system calls; otherwise, we could end up in as bad a shape as MS-DOS.</p>"},{"location":"doc/eram/","title":"What is ERAM?","text":"<p>ERAM is a 4.0 Megabyte expansion memory available to your Commodore with idun-cartridge. It works similar to GeoRAM, but is not compatible and will need a different driver for GEOS. ERAM is not normally used for running code; it's for faster and more convenient access to large data sets, and for sharing memory with the ARM CPU when used in hybrid applications (i.e. apps that use Linux or Lua). You can think of ERAM as poviding \"Extra\", \"External\", or \"Expansion\" memory, but more useful and programmable than just a RAM Disk.</p> <p>Using ERAM from software can be done in multiple ways. You can program it directly using a simple hardware interface controlled by two registers. Or, you can use one of two builtin APIs: the low-level \"Stash API\" or the high-level \"New API\". The high-level API is novel for 8-bit computers; it includes routines to instantly load files from the cartridge SD card to ERAM, and access them by name using familiar, albeit faster, routines like <code>open</code>, <code>read</code>, and <code>seek</code>.</p>"},{"location":"doc/eram/#high-level-eram-api-newmmap","title":"High-level ERAM API (New/Mmap)","text":"<p>This API makes it very simple to use ERAM in an application or tool written for the idun-cartridge. There are only 3 routines.</p> <ol> <li>new - Combines a memory allocation with a memory stash operation. The data in local memory is transferred to ERAM. If an allocation size, but no data is provided, then it's just an alloc with the ERAM initialized to zeroes.</li> <li>memtag - Previously allocated memory (using <code>new</code>) is paired with a hashtag, giving the object in ERAM a name. This allows the data in ERAM to be opened as a file using a filename like \"_:hashtag\".</li> <li>mmap - Combines loading a file into memory with the above hash tagging. A file is instantly loaded to ERAM from the SD card, without passing the data through local memory. So, it's VERY fast. Then, the data in ERAM is accessed using any of the file API, Low-level ERAM API, or hardware interface.</li> </ol>"},{"location":"doc/eram/#file-style-api-for-tagged-eram","title":"File style API for tagged ERAM","text":"<p>As mentioned above, a memory buffer in ERAM can be assigned a name, and then treated as a file in a call to the <code>open</code> routine. The key is to prefix the filename for <code>open</code> with the device previx <code>_:</code>. This tells the <code>open</code> call to locate the file in ERAM. You can then use other file routines (<code>read</code>, <code>seek</code>, etc.) To access the data in a simple and familiar way. Since the data is in ERAM, access is even faster than the normal file access (already pretty fast). But even better is that it's a random access memory buffer that can also be shared by software running on the ARM CPU. This opens many exciting possibilities for future applications.</p>"},{"location":"doc/eram/#low-level-eram-api-stashfetch","title":"Low-level ERAM API (Stash/Fetch)","text":"<p>ERAM is also compatible with the existing, low-level <code>aceMem</code> API calls which still work with local RAM banks too. The routines are <code>aceMemAlloc, aceMemStash, aceMemFetch, and aceMemFree</code>. You should note that memory is automatically garbage collected when a process exits, so calls to <code>aceMemFree</code> are unnecessary and ignored when using ERAM. This API is familiar to many Commodore programmers because it is the same approach used for additional local RAM banks and the REU. You are free to mix &amp; match calls to this API with the ones from the New API and with direct hardware access, if needed. You just have to be sure that you address the RAM buffers correctly, which is done by treating all far memory pointers as 32-bit values.</p> <p>A far memory pointer is stored in zero-page using <code>mp</code></p> ptr byte mp+0 mp+1 mp+2 mp+3 byte offset page bank/block memory type <p>The memory type is either <code>aceMemInternal</code> or <code>aceMemERAM</code>.</p>"},{"location":"doc/eram/#hardware-interface","title":"Hardware interface","text":"<p>Like GeoRAM, ERAM uses two registers in the cartridge IO space to select one page (256 bytes) of the external RAM at a time. The page contents are also accessed using IO space. The registers used to specify the block/page are $defe &amp; $deff.  The definition for each register is pretty simple:</p> 8-bit byte addr 6-bit Page addr 8-bit Block addr $DFxx $DEFE (*bits 0-5) $DEFF * $DEFE bit 6 indicates Ready * $DEFE bit 7 indicates Write mode * $DEFF is a write-only register <p>This scheme provides a total of 22 address bits, thus supporting 4 MiB of ERAM. The 8-bit value stored to $DEFF selects 1 of 256 16 KiB blocks, and the 6-bit value stored to $DEFE selects 1 of 64 pages, each of size 256 bytes. Then, the individual byte is read using an 8-bit offset from $DF00. The memory appears one page at a time in $DFxx.</p> <p>Bit 7 of the Page addr register is used to enable writing to the memory. If this bit is not set, then the memory in $DFxx is read only. If it is set then the memory is write only.</p> <p>Bit 6 of the Page addr register is used as the \"Ready bit\". A \"1\" in this bit location indicates selected ERAM page is ready for access (at $DFxx). After modifying either register, you MUST wait on the Ready bit set to access the page data.</p> <p>The initial setup following reset will have the first page of the last block selected- which we can write as \"$ff/0\". This page is special- it holds the Freemap, which is a list of the number of free pages in each of the 256 ERAM blocks. The Freemap is treated as a read-only page since it is updated automatically by the cartridge. Each time you select a block/page and write some data to it, the Freemap gets updated to reflect the pages you have used.</p> <p>Updating the value of either register will cause the Ready Bit to go low, temporarily. Depending on many factors, the delay before the Ready Bit goes high, and you can access the data, could be from a few Commodore machine cycles to multiple milliseconds. If you attempt to access the page data without waiting for the Ready Bit, you will read invalid data and any writes will be lost. So don't do this.</p> <p>In practice, you should first write the Block addr to $DEFF for the 16KiB Block you want to work with. Wait on the Ready bit to go high, and at that time the first page of the Block is available to read in $DFxx. To select a different page, write the Page addr to $DEFE and again wait on the Ready bit. If you want to write a page, then OR the Page addr with $80 before writing it to the Page addr.</p> <pre><code>    lda #$01\n    sta $deff   ;select block #1\n-   bit $defe\n    bvc -       ;waiting on ready\n    lda #$04\n    sta $defe   ;select page #4\n-   bit $defe\n    bvc -       ;waiting on ready\n    ;now access the data in $dDFxx\n    lda $df00\n    ... and such ...\n</code></pre> <p>For the common use-case of accessing consecutive pages, you can normally just do \"inc $defe\", then wait on the Ready bit. You have to be cognizant of the rollover. Use this simple code to safely advance to the next Page while accounting for rollover.</p> <pre><code>    lda $defe\n    cmp #$ff        ;check if last page of block\n    bne +\n    ;need to select next 16 KiB block in $deff\n    lda next\n    sta $deff       ;0th page will automatically select\n    jmp w           ;jump to wait for Ready\n+   inc $defe\nw:  bit $defe\n    bvc w\n    ;all done; access the next page in $DFxx\n</code></pre>"},{"location":"doc/eram/#block-caching-and-performance","title":"Block caching and performance","text":"<p>The Block you are currently working with is always held in a cache. This allows reading/writing of all pages in the current Block with fast switching between the pages of the Block. However, anytime you change the Block addr, any modified data in the cache must be stored and then the newly selected Block has to be loaded to the cache. Depending on how many pages are used, this can be a slow operation. Therefore, you should only change the Block addr sparingly to not incur this overhead, except when necessary. In practice, you should use the APIs provided in order to get good performance without having to worry much about caching or deal with the hardware interface.</p>"},{"location":"doc/luaref/","title":"Lua","text":""},{"location":"doc/luaref/#idun-to-lua-interface","title":"Idun to Lua Interface","text":""},{"location":"doc/luaref/#introduction","title":"Introduction","text":"<p>Idun provides several methods by which Lua code running on the Raspberry Pi can provide coprocessing functionality to idun tools and applications. First, let's describe the three basic ways of integrating Lua code, from simplest to most complicated:</p>"},{"location":"doc/luaref/#write-a-lua-script-and-execute-it-in-a-tty-from-the-idun-shell","title":"Write a Lua script and execute it in a tty from the idun-shell.","text":"<p>This is by far the easiest way to add applications written in Lua. The idun-shell has a <code>lua</code> command that will accept the name of a Lua script and launch it in a terminal. So, a simple text program written in Lua and using the Lua <code>print()</code> function would just work. To see this in action, switch to the <code>idun-base/apps</code> (usually mapped to <code>e:</code>) directory and type <code>lua sieve.lua</code>. The script is a generic thing that spits out prime numbers up to 10000. It only uses <code>print()</code> for output.</p> <p>To do a more interactive program that requires user input, you simply switch the Lua stdio to use the minisock API described below. Now, every character typed or printed is available on both the Lua and C128 side. To see an example of a script that works this way, simply type <code>help</code> or press <code>F1</code> in the shell. The help system is implemented as a Lua script.</p>"},{"location":"doc/luaref/#write-a-lua-server-that-handles-requests-from-your-idun-client-application","title":"Write a Lua \"server\" that handles requests from your idun \"client\" application.","text":"<p>Included with Idun is an idun-handler Lua object that makes it easy to create client/server applications where Lua does the \"heavy lifting\". For example, the <code>sidplay</code> command relies on a helpful Lua server to pre-process the SID files. </p>"},{"location":"doc/luaref/#write-a-native-idun-application-in-a-combination-of-lua-and-6502-assembler","title":"Write a \"native\" idun application in a combination of Lua and 6502 assembler.","text":"<p>Finally, Idun supports creating applications in Lua in which the C128 is mainly the front-end for rendering graphics, playing sound, and receiving user inputs. In theory, all of the application logic and data processing can be done in Lua. </p> <p>To communicate, messages are passed to the C128 using a \"mailbox\" interface, and these messages can be of arbitrary size and content. Even streaming data as fast as the C128 can handle it is possible. Likewise, there is an \"event\" interface that allows asynchronous events, like user input, to be forwarded to the Lua script. The two best, though simple, examples of this are e:mandelbrot.app and e:cube.app. These Lua/6502 assembler hybrid apps will even work in the idun-vice emulator.</p> <p>Of course, complicated rendering like drawing polygons on the VDC hi-res display, and complicated input like using the mouse, needs support on the C128 side. This is the role of the m8 (\"mate\") API and m8x (\"mate extensions\").</p>"},{"location":"doc/luaref/#mini-socket","title":"mini socket","text":"<p>Under the hood of the Lua interface is a dedicated local socket connection that passes the data stream between the C128 and your script. The <code>minisock</code> is actually a standard Lua way to talk to a socket, and it is augmented by a second Lua object <code>redirect</code>.</p> <p>In the simplest case, the normal way of outputting text to <code>stdout</code> and inputting text from <code>stdin</code> is modified as so:</p> <ul> <li>Instead of <code>print(str)</code> or <code>io.write(str)</code>, you use <code>minisock.write(redirect.stdout, str)</code>.</li> <li>Instead of <code>io.read()</code>, you use <code>key = minisock.read(redirect.stdin, 10000)</code>. The number is a timeout value given in milliseconds; so, 10 seconds for this example. This is just the maximum time you want your script to block waiting on a keystroke from the user. It can be 0 ms to make it non-blocking, or a very big number if you want to block \"forever\". More practically, place it in a loop that polls for other things or does other work.</li> </ul> <p>Minisock can of course be used in a more structured way, such as for passing pre-defined requests and responses between assembler and Lua code. This is where idun-handler provides a helpful and simple solution.</p>"},{"location":"doc/luaref/#idun-handler","title":"idun handler","text":"<p>The handler is included, so you can just <code>require(\"idun-handler\")</code> in your script. Then, you implement a function to handle the requests that your assembler code will send to Lua. In sidplay.lua, for example, the <code>handleRequest(req)</code> function supports 2 types of requests using this simple bit of Lua script:</p> <pre><code>    -- Allowed requests: \"H\"=get sid header, \"P\"=get sid program\n    if req == \"H\" then\n        return sidhdr\n    elseif req == \"P\" then\n        -- Prepend with the size\n        local resp = string.pack(\"&lt;H\", #sidprg)\n        return resp .. sidprg\n    else\n        return nil, 3   -- Bad request\n    end\n</code></pre> <p>Since this isn't the Web, you don't need fancy long names. An \"H\" request and a \"P\" request are sufficient, and these are sent as two-byte messages from the C128 (\"H\\n\" or \"P\\n\"). So, 8-bit efficiency is maintained.</p> <p>Likewise, the response to the \"P\" request is many kilobytes of SID tune data. However, the assembler side just has to copy all that data to RAM as fast as it can read it from the cartridge port.</p>"},{"location":"doc/luaref/#m8-api","title":"m8 API","text":"<p>The m8 (say \"Mate\") API is what allows code written in Lua to run on the Raspberry Pi's processor, but call into 8-bit machine code that's running on the 6502 CPU in your Commodore 128. It's akin to \"old school\" programming on the Commodore using BASIC to call machine language routines, except the high-level script is Lua and runs on a powerful ARM coprocessor. To use m8, just add a line like <code>local m8 = require(\"m8api\")</code> to your Lua program.</p>"},{"location":"doc/luaref/#low-level-m8-functions","title":"Low-level m8 functions","text":"<p>All of the functionality in m8 is ultimately based on just two low-level functions:</p> <pre><code>1. m8.load({6502_ml_code}, load_addr, [start_addr])\n2. m8.intr({6502_ml_code})\n</code></pre> <p>The <code>m8.load</code> function takes some ml code written for the 6502, and quickly loads it into the Commodore at the memory location specified by <code>load_addr</code>. An optional <code>start_addr</code>, if provided, causes a <code>jmp</code> to that address as soon as the code has been loaded. The size of the 6502_code blob that is downloaded to the Commodore is only limited by the RAM available to the 6502.</p> <p>The <code>m8.intr</code> function is used to invoke some inline ml code, which might be as simple as a <code>jsr</code> call to a subroutine in the Commodore memory. Such a subroutine may be a user routine loaded via <code>m8.load</code>, a routine in a running application or tool, an Idun Kernel routine, or even a  routine in Commodore ROM.</p> <p>Since the 6502_code that is provided to <code>m8.intr</code> may be up to 512 bytes, it can be much more complex than just calling a subroutine. Another common use-case would be to treat it as a traditional interrupt handler such that Lua code can both trigger a Commodore interrupt, and provide the handler to run in response, through a simple call to <code>m8.intr</code>.</p>"},{"location":"doc/luaref/#high-level-m8-functions","title":"High-level m8 functions","text":"<p>UNDER CONSTRUCTION</p> <p><code>m8.mailbox</code> is the standard API for message passing from Lua to assembler.</p> <p><code>m8.waitevent</code> is the standard API for receiving input events from assembler in Lua.</p> <p><code>m8.writeln</code> is for outputting lines of text to the display for a full-screen Lua application. For console applications in Lua, you can just use minisock or the Lua <code>print()</code> function.</p> <p><code>m8.file.load_prg</code> is for loading/starting a native program from a Lua script.</p>"},{"location":"doc/luaref/#m8x-extensions","title":"m8x extensions","text":"<p>m8x (\"mate extensions\") is the standard way to add application-dependent functionality to Lua apps. These extensions become part of the callable code in the m8 namespace created by the applications. So, it allows new functionality to be invoked on the assembler side. For an example, see: cube.app.d and mandelbrot.app.d.</p>"},{"location":"doc/luaref/#system-sys-functions","title":"System (sys.) functions","text":"<p>UNDER CONSTRUCTION</p>"},{"location":"doc/luaref/#user-usr-functions","title":"User (usr.) functions","text":"<p>UNDER CONSTRUCTION</p>"},{"location":"doc/setup-rpi/","title":"Setup","text":""},{"location":"doc/setup-rpi/#logging-in-to-the-raspberry-pi","title":"Logging in to the Raspberry Pi","text":"<p>From the idun-shell, you can access Linux to setup networking and other services. You will be logged in as user <code>idun</code> automatically, and you will have <code>sudo</code> ability. The default password is \"idun\", and the default root password is \"Commodore\".</p> <p>The idun-cartridge ships with <code>ssh</code> and the idun-filebrowser enabled. You should attach the cartridge to your network using wired Ethernet and/or setup the WiFi connection.</p> <p>If your network supports <code>.local</code> host names, then your cartridge should appear on the network as host \"idunpi\" or \"idunpi.local\". If not, then use the Linux prompt to discover the cartridge ip address. Then, use <code>ssh</code> or browse to port 8080 for the idun-filebrowser.</p>"},{"location":"doc/setup-rpi/#resize-file-system-extend-root-partition","title":"Resize file system / extend root partition","text":"<p>After imaging the minimal image, use one of: 1. Arch Linux \"Disks\" GUI 2. Linux \"GParted\" GUI 3. Linux <code>fdisk</code> and <code>resize2fs</code> tools. 4. \"GParted Live\" boot disk on PC</p> <p>In all cases, BE VERY CAREFUL! It is easy to lose all the data on your device if you mess up using <code>fdisk</code> or another partition tool.</p> <p>It IS POSSIBLE to expand the file system on the idun-cartridge directly, using the Linux terminal and <code>fdisk</code> + <code>resize2fs</code>, which are included with the minimal image. Try this at your own RISK!</p> <ol> <li>First, use <code>fdisk</code> to delete the 2nd partition, and re-create the 2nd partition using the maximum available space on your SD card.</li> <li><code>sudo fdisk /dev/mmcblk0</code></li> <li>At the fdisk prompt, type \"d\", then \"2\" to delete 2nd partition. <li>Then \"n\", \"p\", \"2\" to re-create a primary partition #2. Choose the default starting and ending blocks AND select \"N\" to NOT REMOVE the partition's signature. <li>Finally \"w\" to write the updated partition table to disk. You must reboot for the change to take effect.</li> <li><code>sudo reboot now</code></li> <li>After the reboot and back at the Linux terminal: <code>sudo resize2fs /dev/mmcblk0p2</code>.</li> <li>If all went well, then <code>df -h</code> should show max. space available for your SD card on the root partition.</li>"},{"location":"doc/setup-rpi/#configure-networking-after-connecting-cartridge-to-commodore","title":"Configure Networking after connecting cartridge to Commodore","text":"<p>Enable wired USB Ethernet</p> <pre><code>ping www.google.com\nping idunpi (from another host on the LAN)\nnetworkctl list\nip link set up enuX\n</code></pre> <p>Networking Wiki</p> <p>Enable Wi-Fi</p> <pre><code>sudo systemctl enable connman\nsudo systemctl start connman\n</code></pre> <p>Use connmanctl CLI command to configure wi-fi</p> <p>Connman Wiki</p>"},{"location":"doc/setup-rpi/#build-open-source-code-optional","title":"Build open source code (optional)","text":"<ol> <li>Clone this repository to your idun home directory: <code>git clone https://github.com/idun-project/idun-cartridge</code></li> <li><code>cd idun-cartridge &amp;&amp; ./setup.sh</code> -installs additional packages such as acme and idun-zcc.</li> <li><code>cd cbm &amp;&amp; make</code> -builds cartridge software and updates the <code>sys</code> directroy (<code>z:</code> device in the idun-shell)</li> </ol>"},{"location":"doc/setup-rpi/#emulation-of-the-cartridge-on-the-raspberry-pi-optional","title":"Emulation of the cartridge on the Raspberry Pi (optional)","text":"<ol> <li>Install patched VICE emulator- <code>sudo pacman -Sy idun-vice</code>, and see idun-vice.</li> </ol>"},{"location":"doc/shell/","title":"Idun Shell","text":"<p>The file <code>dos.app</code>, with source in <code>cbm/dos.app.s</code>, is the Idun Shell, a command-line interface for the Idun cartridge that emulates the behavior of MS-DOS. It is the primary application that loads on startup if you just type the <code>go</code> command from BASIC, or if you specify it using <code>go \"dos\"</code>.</p> <p>Here is a summary of its key features and structure:</p> <ul> <li> <p>Core Functionality: It provides a classic command-line environment where users can enter commands at a prompt. It parses these commands, handles arguments, and executes them.</p> </li> <li> <p>Startup Process:</p> <ul> <li>It includes a resident Toolbox (<code>sys/toolbox.asm</code>), making a set of common routines available for other tools and applications that are launched from the shell.</li> <li>It supports an <code>autoexec.bat</code>-like script (<code>z:autoexec.bat</code>) which runs automatically on startup to configure the environment.</li> <li>It features a \"fast reload\" capability, caching parts of itself in ERAM to speed up subsequent launches.</li> </ul> </li> <li> <p>Command Dispatcher:</p> <ul> <li>The shell has a table of internal commands for common tasks (e.g., <code>dir</code>, <code>cd</code>, <code>type</code>, <code>mem</code>).</li> <li>If a command is not found internally, it attempts to load and execute an external program from a disk or virtual drive.</li> </ul> </li> <li> <p>Key Features:</p> <ul> <li>I/O Redirection: Supports redirecting input and output using <code>&lt;</code>, <code>&gt;</code>, and <code>&gt;&gt;</code>, similar to DOS and Unix shells.</li> <li>Wildcard Support: Allows the use of <code>*</code> in filenames for commands that operate on multiple files.</li> <li>Batch File Execution: Can run scripts of shell commands using the <code>exec</code> command.</li> <li>Drive Management: Includes <code>mount</code> to attach disk images and <code>assign</code> to map host directories to virtual drive letters.</li> <li>System Interaction: Provides commands like <code>mem</code> to view memory usage and <code>info</code> to display information about system devices.</li> <li>Host Integration: Features powerful commands like <code>lua</code>, <code>nix</code>, and <code>linux</code> that pass commands through a <code>tty</code> interface to be executed on the host system (the Raspberry Pi).</li> <li>Macros: Implements a <code>doskey</code>-like macro system for creating command aliases.</li> <li>Screen Saver: Includes a simple countdown timer that launches a <code>blanker</code> application after a period of inactivity.</li> </ul> </li> </ul>"},{"location":"doc/toolbox/","title":"Toolbox","text":""},{"location":"doc/toolbox/#toolbox-apis","title":"Toolbox APIs","text":"<p>The Toolbox is a small set of reusable ML routines (~4 KiB) that are available alongside the Idun Kernel routines to make it easier to develop text-based tools in assembly language. These tools are launched from Idun Dos, and return the user to Dos when complete. By utilizing the Toolbox, tools can provide a simpler and more consistent user and programming experience. There are 7 APIs for the following purposes:</p> <ol> <li>user: An API for UI and decorative text</li> <li>win: An API for defining window areas managed by tools that take over the screen.</li> <li>stat; An API for using the status bar that appears at the top of the screen when tools are running.</li> <li>keys: An API for programming command keys used by the tool.</li> <li>tmo: An API for setting one-shot timeouts to invoke a callback.</li> <li>sys: An API for calling System utilities</li> </ol>"},{"location":"doc/toolbox/#tooluser","title":"toolUser","text":"<p>This API works for console and full-screen tools. For console tools, it is mainly useful for creating text that stands out against the more mundane console output through the use of colors, lines, or borders. When used for a full-screen tool, it can also provide \"popup\" dialogs, menus, or help.</p> <p>The interface to the user API is designed so it can be data-driven. Therefore, the parameters to each function are embedded in the code, immediately following the <code>jsr</code> for the function.</p> <p><code>toolUserLayout/End</code> enable/disable active UI layout</p> <ul> <li>param = !byte 2 [layout-flags, width-or-height]</li> <li>layout-flags = h|r|o|x|x|x|x|x, where<ul> <li>h = horizontal (0=vertical)</li> <li>r = retained (0=not retained)</li> <li>o = overlayed (0=not overlayed)</li> </ul> </li> <li>width-or-height = number of characters wide or high, depending on if it is to be layed out vertically or horizontally.</li> </ul> <p><code>toolUserNode/End</code> start/end a text area definition</p> <ul> <li>param = !byte 3 [refresh-flag,width,height]</li> <li>refresh-flag = refresh counter to control redraw during vsync interrupt; only used for retained layout!</li> <li>width = width of text area in characters</li> <li>height = height of text area in characters</li> </ul> <p><code>toolUserGadget</code></p> <ul> <li>param !byte 1 gadget-flags</li> <li>gadget-flags = f|s|x|x|x|pen, where<ul> <li>f = focus</li> <li>s = select</li> <li>pen = fgrd pen</li> </ul> </li> <li>param !pet null-terminated gadget text (PETSCII)</li> </ul> <p><code>toolUserLabel</code></p> <ul> <li>param !pet null-terminated gadget text (PETSCII)</li> </ul> <p><code>toolUserSeparator</code> outputs a horizontal line used as a separator</p> <p>The following variables can be set and will be global to the text area (e.g. the \"node\") within which they are modified.</p> <p><code>toolUserColor</code> upper nybble is border pen; lower nybble is text pen</p> <p><code>toolUserStyles</code> = b|a|r|u|f|c|&gt;|&lt;, where</p> <pre><code>    - b = bordered text\n    - a = \n    - r = reverse text\n    - u = underline text\n    - f = \n    - c = center text\n    - &lt; = left=align text\n    - &gt; = right-align text\n</code></pre>"},{"location":"doc/toolbox/#toolwin","title":"toolWin","text":"<p>This API is for tools that take over screen drawing, rather than just outputting to a scrolling console. They are useful for defining screen and active region dimensions, color palette, and character set. The active region can be scrolled vertically, and can be cached and retrieved to support popups.</p> <p><code>toolWinB</code> defines the variables that can be set. - toolWinRegion: define rows x cols and top-left - toolWinScroll: scrolling rows x cols and top-left - toolWinPalette: colors to use for 8x palette entries</p> <p><code>toolWinRestore</code> restores the window setup back to the default and should be called at exit by any tool that manipulates the screen window, palette, etc.</p>"},{"location":"doc/toolbox/#toolstat","title":"toolStat","text":"<p>This API is for manipulating the top line of the display, which is consistently used as a status bar. A minimum use would be to set a title for an interactive tool, which is displayed at the top left of the screen. Tools can ignore this API and the status bar will continue updating the standard values it displays automatically, such as the time &amp; date.</p> <p><code>toolStatB</code> defines the variables that can be set.</p> <p><code>toolStatTitle</code> sets the title string</p> <p><code>toolStatAlert</code> temporarily replace status line text with alert message</p>"},{"location":"doc/toolbox/#toolkeys","title":"toolKeys","text":"<p>This API is for defining the tool's command keys and their handlers.</p> <p><code>toolKeysSet</code> set up a command key handler</p> <p><code>toolKeysMacro</code> set up a macro key (up to 32 chars)</p> <p><code>toolKeysRemove</code> removes a command key and handler</p> <p><code>toolKeysHandler</code> call this API to check for a command key in the input and handle it.</p> <p>Any key code can be used by the tool. However, reusing key codes already defined by the user as described below will override the user-defined function. Therefore, most tools should only use key codes outside the range $80-$8f for command keys.</p> <p>In addition to command keys, up to 16 user-defined function key macro definitions may be created by the user with the <code>funkey</code> shell command. These user-defined keys are used to inject a macro string (up to 32 chars) any time the key is pressed from within any tool, including in the DOS shell itself.</p> <p>Only the keycodes $80-$8f may be used with the <code>funkey</code> command. This includes F1-F12 codes, plus SH-HELP, SH-RUN, SH-RETURN. The code for CO-1 ($81) is specifically excluded by <code>funkey</code> and is available as an application command key instead.</p>"},{"location":"doc/toolbox/#tooltmo","title":"toolTmo","text":"<p>This API provides two functions for setting a countdown timer and invoking a callback function when the timer expires. It is based on the per-frame Irq handler, so the shortest timeout possible is roughly the time of one video frame. For timeouts of a few seconds or shorter, use <code>toolTmoJifs</code> to countdown 1-255 \"jiffies\" (~that many frames). For longer timeouts, use <code>toolTmoSecs</code> to countdown 1-255 seconds (allows ~4.25 mins). All timeouts occur only once, and you will need to reset them to trigger another. Also, calling either API will supercede any pending timeout that was counting down before.</p> <p><code>toolTmoJifs</code> invoke callback routine after 1-255 \"jiffies\"</p> <p><code>toolTmoSecs</code> invoke callback routine after 1-255 seconds</p>"},{"location":"doc/toolbox/#toolsys","title":"toolSys","text":"<p>This API allows the tool to call other system tools by executing a sub-process with arguments.</p> <p><code>toolSyscall</code> invoke a sub-process</p>"}]}